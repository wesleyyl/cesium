# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The RoadRunner SBML Simulation Engine, (c) 2009-2014 Andy Somogyi and Herbert Sauro"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _roadrunner
else:
    import _roadrunner

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _roadrunner.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _roadrunner.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _roadrunner.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _roadrunner.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _roadrunner.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _roadrunner.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _roadrunner.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _roadrunner.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _roadrunner.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _roadrunner.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _roadrunner.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _roadrunner.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _roadrunner.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _roadrunner.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _roadrunner.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _roadrunner.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _roadrunner:
_roadrunner.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _roadrunner.SHARED_PTR_DISOWN
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _roadrunner.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _roadrunner.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _roadrunner.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _roadrunner.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _roadrunner.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _roadrunner.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _roadrunner.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _roadrunner.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _roadrunner.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _roadrunner.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _roadrunner.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _roadrunner.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _roadrunner.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _roadrunner.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _roadrunner.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _roadrunner.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _roadrunner.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _roadrunner.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _roadrunner.IntVector_rend(self)

    def clear(self) -> "void":
        return _roadrunner.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _roadrunner.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _roadrunner.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _roadrunner.IntVector_erase(self, *args)

    def __init__(self, *args):
        _roadrunner.IntVector_swiginit(self, _roadrunner.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _roadrunner.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _roadrunner.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _roadrunner.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _roadrunner.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _roadrunner.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _roadrunner.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _roadrunner.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _roadrunner.IntVector_capacity(self)
    __swig_destroy__ = _roadrunner.delete_IntVector

# Register IntVector in _roadrunner:
_roadrunner.IntVector_swigregister(IntVector)

class DictionaryVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _roadrunner.DictionaryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _roadrunner.DictionaryVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _roadrunner.DictionaryVector___bool__(self)

    def __len__(self) -> "std::vector< rr::Dictionary const * >::size_type":
        return _roadrunner.DictionaryVector___len__(self)

    def __getslice__(self, i: "std::vector< rr::Dictionary const * >::difference_type", j: "std::vector< rr::Dictionary const * >::difference_type") -> "std::vector< rr::Dictionary const *,std::allocator< rr::Dictionary const * > > *":
        return _roadrunner.DictionaryVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _roadrunner.DictionaryVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< rr::Dictionary const * >::difference_type", j: "std::vector< rr::Dictionary const * >::difference_type") -> "void":
        return _roadrunner.DictionaryVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _roadrunner.DictionaryVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< rr::Dictionary const * >::value_type":
        return _roadrunner.DictionaryVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _roadrunner.DictionaryVector___setitem__(self, *args)

    def pop(self) -> "std::vector< rr::Dictionary const * >::value_type":
        return _roadrunner.DictionaryVector_pop(self)

    def append(self, x: "Dictionary") -> "void":
        return _roadrunner.DictionaryVector_append(self, x)

    def empty(self) -> "bool":
        return _roadrunner.DictionaryVector_empty(self)

    def size(self) -> "std::vector< rr::Dictionary const * >::size_type":
        return _roadrunner.DictionaryVector_size(self)

    def swap(self, v: "DictionaryVector") -> "void":
        return _roadrunner.DictionaryVector_swap(self, v)

    def begin(self) -> "std::vector< rr::Dictionary const * >::iterator":
        return _roadrunner.DictionaryVector_begin(self)

    def end(self) -> "std::vector< rr::Dictionary const * >::iterator":
        return _roadrunner.DictionaryVector_end(self)

    def rbegin(self) -> "std::vector< rr::Dictionary const * >::reverse_iterator":
        return _roadrunner.DictionaryVector_rbegin(self)

    def rend(self) -> "std::vector< rr::Dictionary const * >::reverse_iterator":
        return _roadrunner.DictionaryVector_rend(self)

    def clear(self) -> "void":
        return _roadrunner.DictionaryVector_clear(self)

    def get_allocator(self) -> "std::vector< rr::Dictionary const * >::allocator_type":
        return _roadrunner.DictionaryVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _roadrunner.DictionaryVector_pop_back(self)

    def erase(self, *args) -> "std::vector< rr::Dictionary const * >::iterator":
        return _roadrunner.DictionaryVector_erase(self, *args)

    def __init__(self, *args):
        _roadrunner.DictionaryVector_swiginit(self, _roadrunner.new_DictionaryVector(*args))

    def push_back(self, x: "Dictionary") -> "void":
        return _roadrunner.DictionaryVector_push_back(self, x)

    def front(self) -> "std::vector< rr::Dictionary const * >::value_type":
        return _roadrunner.DictionaryVector_front(self)

    def back(self) -> "std::vector< rr::Dictionary const * >::value_type":
        return _roadrunner.DictionaryVector_back(self)

    def assign(self, n: "std::vector< rr::Dictionary const * >::size_type", x: "Dictionary") -> "void":
        return _roadrunner.DictionaryVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _roadrunner.DictionaryVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _roadrunner.DictionaryVector_insert(self, *args)

    def reserve(self, n: "std::vector< rr::Dictionary const * >::size_type") -> "void":
        return _roadrunner.DictionaryVector_reserve(self, n)

    def capacity(self) -> "std::vector< rr::Dictionary const * >::size_type":
        return _roadrunner.DictionaryVector_capacity(self)
    __swig_destroy__ = _roadrunner.delete_DictionaryVector

# Register DictionaryVector in _roadrunner:
_roadrunner.DictionaryVector_swigregister(DictionaryVector)


def sigtrap() -> "size_t":
    return _roadrunner.sigtrap()
class Dictionary(object):
    r"""
    This class is frozen, no new features
    A dictionary interface that objects can implement. These are automatically
    mapped to python dictionaries.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def keys(self) -> "PyObject *":
        r"""
        implement the python method if we are being used in the python binding.

        Note, if these methods are added to an %extend section, derived classes
        will not see them, so as far as I can tell, this is the only way to
        add these methods.
        """
        return _roadrunner.Dictionary_keys(self)

    def values(self) -> "PyObject *":
        return _roadrunner.Dictionary_values(self)

    def items(self) -> "PyObject *":
        return _roadrunner.Dictionary_items(self)

    def __getitem__(self, key: "char const *") -> "PyObject *":
        return _roadrunner.Dictionary___getitem__(self, key)

    def __setitem__(self, key: "char const *", value: "PyObject *") -> "PyObject *":
        return _roadrunner.Dictionary___setitem__(self, key, value)

    def __delitem__(self, key: "char const *") -> "void":
        return _roadrunner.Dictionary___delitem__(self, key)

    def __contains__(self, key: "char const *") -> "PyObject *":
        return _roadrunner.Dictionary___contains__(self, key)

    def helloPython(self) -> "std::string":
        return _roadrunner.Dictionary_helloPython(self)

# Register Dictionary in _roadrunner:
_roadrunner.Dictionary_swigregister(Dictionary)

class BasicDictionary(Dictionary):
    r"""
    This class is frozen, no new features
    Basic implementation of the Dictionary interface which uses a
    std unordered std::map to store the values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _roadrunner.BasicDictionary_swiginit(self, _roadrunner.new_BasicDictionary())
    __swig_destroy__ = _roadrunner.delete_BasicDictionary

# Register BasicDictionary in _roadrunner:
_roadrunner.BasicDictionary_swigregister(BasicDictionary)

class LoadSBMLOptions(BasicDictionary):
    r"""
    Options for loading SBML into RoadRunner.

    Future version may add additional fields to the end of this struct,
    this way we can maintain binary compatibility with older RoadRunner versions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CONSERVED_MOIETIES = _roadrunner.LoadSBMLOptions_CONSERVED_MOIETIES
    r"""
    perform conservation analysis.

    This causes a re-ordering of the species, so results generated
    with this flag enabled can not be compared index wise to results
    generated otherwise.

    currently only implemented with the C code generating model
    """
    RECOMPILE = _roadrunner.LoadSBMLOptions_RECOMPILE
    r"""
    Should the model be recompiled?
    The LLVM ModelGenerator maintins a hash table of currently running
    models. If this flag is NOT set, then the generator will look to see
    if there is already a running instance of the given model and
    use the generated code from that one.

    If only a single instance of a model is run, there is no
    need to cache the models, and this can safetly be enabled,
    realizing some performance gains.
    """
    READ_ONLY = _roadrunner.LoadSBMLOptions_READ_ONLY
    r"""
    If this is set, then a read-only model is generated. A read-only
    model can be simulated, but no code is generated to set model
    values, i.e. parameters, amounts, values, etc...

    It takes a finite amount of time to generate the model value setting
    functions, and if they are not needed, one may see some performance
    gains, especially in very large models.
    """
    MUTABLE_INITIAL_CONDITIONS = _roadrunner.LoadSBMLOptions_MUTABLE_INITIAL_CONDITIONS
    r"""
    Generate accessor functions to allow changing of initial
    conditions.
    """
    OPTIMIZE_GVN = _roadrunner.LoadSBMLOptions_OPTIMIZE_GVN
    r"""
    GVN - This pass performs global value numbering and redundant load
    elimination cotemporaneously.
    """
    OPTIMIZE_CFG_SIMPLIFICATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_CFG_SIMPLIFICATION
    r"""
    CFGSimplification - Merge basic blocks, eliminate unreachable blocks,
    simplify terminator instructions, etc...
    """
    OPTIMIZE_INSTRUCTION_COMBINING = _roadrunner.LoadSBMLOptions_OPTIMIZE_INSTRUCTION_COMBINING
    r"""
    InstructionCombining - Combine instructions to form fewer, simple
    instructions. This pass does not modify the CFG, and has a tendency to make
    instructions dead, so a subsequent DCE pass is useful.
    """
    OPTIMIZE_DEAD_INST_ELIMINATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_DEAD_INST_ELIMINATION
    r"""
    DeadInstElimination - This pass quickly removes trivially dead instructions
    without modifying the CFG of the function.  It is a BasicBlockPass, so it
    runs efficiently when queued next to other BasicBlockPass's.
    """
    OPTIMIZE_DEAD_CODE_ELIMINATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_DEAD_CODE_ELIMINATION
    r"""
    DeadCodeElimination - This pass is more powerful than DeadInstElimination,
    because it is worklist driven that can potentially revisit instructions when
    their other instructions become dead, to eliminate chains of dead
    computations.
    """
    OPTIMIZE_INSTRUCTION_SIMPLIFIER = _roadrunner.LoadSBMLOptions_OPTIMIZE_INSTRUCTION_SIMPLIFIER
    r"""InstructionSimplifier - Remove redundant instructions."""
    OPTIMIZE = _roadrunner.LoadSBMLOptions_OPTIMIZE
    r"""
    all optimizations, use to check if bit mask has
    any optimizations.
    """
    USE_MCJIT = _roadrunner.LoadSBMLOptions_USE_MCJIT
    r"""
    Use the LLVM MCJIT JIT engine.

    Defaults to false.

    The MCJIT is the new LLVM JIT engine, it is not as well tested as the
    original JIT engine. Does NOT work on LLVM 3.1
    """
    LLVM_SYMBOL_CACHE = _roadrunner.LoadSBMLOptions_LLVM_SYMBOL_CACHE
    TURN_ON_VALIDATION = _roadrunner.LoadSBMLOptions_TURN_ON_VALIDATION
    r"""Turn on SBML validation"""
    NO_DEFAULT_SELECTIONS = _roadrunner.LoadSBMLOptions_NO_DEFAULT_SELECTIONS
    r"""Do not create a default selection list when the model is loaded."""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        initializes the struct with the default options.


        |

        *Overload 2:*

        creates an object from an existing dictionary.
        """
        _roadrunner.LoadSBMLOptions_swiginit(self, _roadrunner.new_LoadSBMLOptions(*args))
    version = property(_roadrunner.LoadSBMLOptions_version_get, _roadrunner.LoadSBMLOptions_version_set, doc=r"""the version this struct""")
    size = property(_roadrunner.LoadSBMLOptions_size_get, _roadrunner.LoadSBMLOptions_size_set, doc=r"""sizeof this struct""")
    modelGeneratorOpt = property(_roadrunner.LoadSBMLOptions_modelGeneratorOpt_get, _roadrunner.LoadSBMLOptions_modelGeneratorOpt_set)
    loadFlags = property(_roadrunner.LoadSBMLOptions_loadFlags_get, _roadrunner.LoadSBMLOptions_loadFlags_set)

    def getConservedMoietyConversion(self) -> "bool":
        return _roadrunner.LoadSBMLOptions_getConservedMoietyConversion(self)

    def setConservedMoietyConversion(self, val: "bool") -> "void":
        return _roadrunner.LoadSBMLOptions_setConservedMoietyConversion(self, val)

    def setValidation(self, val: "bool") -> "void":
        return _roadrunner.LoadSBMLOptions_setValidation(self, val)
    __swig_destroy__ = _roadrunner.delete_LoadSBMLOptions
    conservedMoieties = property(_roadrunner.LoadSBMLOptions_conservedMoieties_get, _roadrunner.LoadSBMLOptions_conservedMoieties_set, doc=r"""

    :annotation: bool

    perform conservation analysis.

    This causes a re-ordering of the species, so results generated
    with this flag enabled can not be compared index wise to results
    generated otherwise.

    Moiety conservation is only compatable with simple models which do NOT have any events or rules
    which define or alter any floating species, and which have simple constant stiochiometries.

    """)
    mutableInitialConditions = property(_roadrunner.LoadSBMLOptions_mutableInitialConditions_get, _roadrunner.LoadSBMLOptions_mutableInitialConditions_set, doc=r"""

    :annotation: bool

    Generate accessor functions to allow changing of initial
    conditions.

    """)
    noDefaultSelections = property(_roadrunner.LoadSBMLOptions_noDefaultSelections_get, _roadrunner.LoadSBMLOptions_noDefaultSelections_set, doc=r"""

    :annotation: bool

    Do not create a default selection list when the model is loaded.

    """)
    readOnly = property(_roadrunner.LoadSBMLOptions_readOnly_get, _roadrunner.LoadSBMLOptions_readOnly_set, doc=r"""

    :annotation: bool

    Should the model be recompiled?
    The LLVM ModelGenerator maintins a hash table of currently running
    models. If this flag is NOT set, then the generator will look to see
    if there is already a running instance of the given model and
    use the generated code from that one.

    If only a single instance of a model is run, there is no
    need to cache the models, and this can safetly be enabled,
    realizing some performance gains.

    """)
    recompile = property(_roadrunner.LoadSBMLOptions_recompile_get, _roadrunner.LoadSBMLOptions_recompile_set, doc=r"""

    :annotation: bool

    If this is set, then a read-only model is generated. A read-only
    model can be simulated, but no code is generated to set model
    values, i.e. parameters, amounts, values, etc...

    It takes a finite amount of time to generate the model value setting
    functions, and if they are not needed, one may see some performance
    gains, especially in very large models.

    """)

# Register LoadSBMLOptions in _roadrunner:
_roadrunner.LoadSBMLOptions_swigregister(LoadSBMLOptions)

class SimulateOptions(object):
    r"""
    This class is frozen, no new features
    RoadRunner simulation options.

    This is the full set of options that determines how RoadRunner performs
    a simulation of an sbml model.

    This is a superset of the values stored in a sbml test suite settings file, the
    documentation of the fields which correspond to an sbml test suite settings was
    taken from http://sbml.org
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        r"""init with default options."""
        _roadrunner.SimulateOptions_swiginit(self, _roadrunner.new_SimulateOptions())
    reset_model = property(_roadrunner.SimulateOptions_reset_model_get, _roadrunner.SimulateOptions_reset_model_set, doc=r"""reset the model to the initial state.""")
    structured_result = property(_roadrunner.SimulateOptions_structured_result_get, _roadrunner.SimulateOptions_structured_result_set, doc=r"""
    Simulate should return a raw result matrix without
    adding any column names.
    """)
    copy_result = property(_roadrunner.SimulateOptions_copy_result_get, _roadrunner.SimulateOptions_copy_result_set, doc=r"""
    Make a copy of the simulation result in Python.
    Large simulations should have this disabled.
    """)
    steps = property(_roadrunner.SimulateOptions_steps_get, _roadrunner.SimulateOptions_steps_set, doc=r"""
    The number of steps at which the output is sampled. The samples are evenly spaced.
    When a simulation system calculates the data points to record, it will typically
    divide the duration by the number of time steps. Thus, for X steps, the output
    will have X+1 data rows.
    """)
    start = property(_roadrunner.SimulateOptions_start_get, _roadrunner.SimulateOptions_start_set, doc=r"""
    The start time of the simulation time-series data.
    Often this is 0, but not necessarily.
    """)
    duration = property(_roadrunner.SimulateOptions_duration_get, _roadrunner.SimulateOptions_duration_set, doc=r"""



    The duration of the simulation run, in the model's units of time. Note,
    setting the duration automatically sets the end time and visa versa.

    """)
    output_file = property(_roadrunner.SimulateOptions_output_file_get, _roadrunner.SimulateOptions_output_file_set, doc=r"""


    The output file path to write to, if not empty. 

    If not empty, the simulation results will be written to the path specified
    by output_file during the simulation, in batches. Specifically, the results
    will be written as soon as Config::K_ROWS_PER_WRITE rows are in the result
    buffer. The result buffer will be cleared every time it is written, so
    simulate() will return an empty matrix.

    If it is empty, simulation is done as usual and the full result matrix will
    be returned.

    """)
    variables = property(_roadrunner.SimulateOptions_variables_get, _roadrunner.SimulateOptions_variables_set, doc=r"""



    The variables (in addition to time) whose values will be saved in the result.
    These are SBML model id's. Order is significant, as this determines the order
    of the columns in the result matrix.

    Important: if a symbol in this list refers to a species in the model,
    then that symbol should also be listed in either the amount or concentration
    lists below. If a species symbol is listed in variables, but is not listed
    in either amounts or concentrations, then it defaults to an amount value.

    The ordering of the symbols in variable is what determines the output
    ordering. The order of symbols in either amounts or concentrations do not
    effect the output ordering.

    NOTE:If a listed variable has two underscores in it ('__'), that variable
    is actually present only in a submodel of the main model, from the
    Hierarchical Model Composition package, in the format submodelID__variableID.
    If the model is flattened, the variable will appear automatically.

    """)
    amounts = property(_roadrunner.SimulateOptions_amounts_get, _roadrunner.SimulateOptions_amounts_set, doc=r"""
    A list of the variable whose output in the results file is in amount
    (not concentration) units. This list of variables must be a subset of
    the names listed in variables.
    """)
    concentrations = property(_roadrunner.SimulateOptions_concentrations_get, _roadrunner.SimulateOptions_concentrations_set, doc=r"""



    A list of the variable whose output in the results file is in concentration
    (not amount) units. This list of variables must be a subset of the names
    listed in variables.

    """)
    times = property(_roadrunner.SimulateOptions_times_get, _roadrunner.SimulateOptions_times_set)

    def toString(self) -> "std::string":
        r"""get a description of this object, compatable with python __str__"""
        return _roadrunner.SimulateOptions_toString(self)

    def toRepr(self) -> "std::string":
        r"""get a short descriptions of this object, compatable with python __repr__."""
        return _roadrunner.SimulateOptions_toRepr(self)

    def loadSBMLSettings(self, filename: "std::string const &") -> "void":
        return _roadrunner.SimulateOptions_loadSBMLSettings(self, filename)

    def initialize(self) -> "void":
        return _roadrunner.SimulateOptions_initialize(self)

    def getNext(self, step: "size_t") -> "double":
        return _roadrunner.SimulateOptions_getNext(self, step)

    def reset(self) -> "void":
        r"""Reset all values to defaults."""
        return _roadrunner.SimulateOptions_reset(self)
    end = property(_roadrunner.SimulateOptions_end_get, _roadrunner.SimulateOptions_end_set, doc=r"""



    The simulation end time. Note, setting the end time automatically sets the
    duration accordingly and visa versa.

    """)
    structuredResult = property(_roadrunner.SimulateOptions_structuredResult_get, _roadrunner.SimulateOptions_structuredResult_set)
    copyResult = property(_roadrunner.SimulateOptions_copyResult_get, _roadrunner.SimulateOptions_copyResult_set)

    def __repr__(self) -> "std::string":
        return _roadrunner.SimulateOptions___repr__(self)

    def __str__(self) -> "std::string":
        return _roadrunner.SimulateOptions___str__(self)

    def copy(self) -> "PyObject *":
        r"""
        makes a copy of this object.
        Python normally just keeps references to objects, and this forces a true
        copy. Note, we heed to add the SWIG_POINTER_OWN to the function below
        so that when the returned object is destroyed (by Python), the C++
        object will also be deleted.
        """
        return _roadrunner.SimulateOptions_copy(self)

    def getListener(self):
        return self._getListener()

    def setListener(self, listener):
        if listener is None:
            self._clearListener()
        else:
            self._setListener(listener)

    __swig_destroy__ = _roadrunner.delete_SimulateOptions

# Register SimulateOptions in _roadrunner:
_roadrunner.SimulateOptions_swigregister(SimulateOptions)

class RoadRunnerOptions(object):
    r"""
    A set of options that determine how the top level RoadRunner class
    should behave.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DISABLE_PYTHON_DYNAMIC_PROPERTIES = _roadrunner.RoadRunnerOptions_DISABLE_PYTHON_DYNAMIC_PROPERTIES
    r"""
    RoadRunner by default dynamically generates accessor properties
    for all sbml symbol names on the model object when it is retrieved
    in Python. This feature is very nice for interactive use, but
    can slow things down. If this feature is not needed, it
    can be disabled here.
    """
    flags = property(_roadrunner.RoadRunnerOptions_flags_get, _roadrunner.RoadRunnerOptions_flags_set, doc=r"""a bitmask of the options specified in the Options enumeration.""")
    jacobianStepSize = property(_roadrunner.RoadRunnerOptions_jacobianStepSize_get, _roadrunner.RoadRunnerOptions_jacobianStepSize_set, doc=r"""step size used for numeric Jacobian calculations.""")

    def __init__(self):
        r"""load default valued from config."""
        _roadrunner.RoadRunnerOptions_swiginit(self, _roadrunner.new_RoadRunnerOptions())
    disablePythonDynamicProperties = property(_roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_get, _roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_set)
    __swig_destroy__ = _roadrunner.delete_RoadRunnerOptions

# Register RoadRunnerOptions in _roadrunner:
_roadrunner.RoadRunnerOptions_swigregister(RoadRunnerOptions)

class Compiler(object):
    r"""
    interface to manipulate 'compiler' settings.

    In the C generating model sytem, an external C compiler is used to compile
    generated C code. However, in the LLVM system, there is no code generation
    nor compilation, so this interface is not really usefull, but is implemented
    for compatiblity with the C system.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getCompiler(self) -> "std::string":
        return _roadrunner.Compiler_getCompiler(self)

    def setCompiler(self, compiler: "std::string const &") -> "bool":
        return _roadrunner.Compiler_setCompiler(self, compiler)

    def getCompilerLocation(self) -> "std::string":
        return _roadrunner.Compiler_getCompilerLocation(self)

    def setCompilerLocation(self, path: "std::string const &") -> "bool":
        return _roadrunner.Compiler_setCompilerLocation(self, path)

    def getSupportCodeFolder(self) -> "std::string":
        return _roadrunner.Compiler_getSupportCodeFolder(self)

    def setSupportCodeFolder(self, path: "std::string const &") -> "bool":
        return _roadrunner.Compiler_setSupportCodeFolder(self, path)

    def getDefaultTargetTriple(self) -> "std::string":
        r"""
        getDefaultTargetTriple() - Return the default target triple the compiler
        has been configured to produce code for.

        The target triple is a std::string in the format of:
          CPU_TYPE-VENDOR-OPERATING_SYSTEM
        or
          CPU_TYPE-VENDOR-KERNEL-OPERATING_SYSTEM
        """
        return _roadrunner.Compiler_getDefaultTargetTriple(self)

    def getProcessTriple(self) -> "std::string":
        r"""
        getProcessTriple() - Return an appropriate target triple for generating
        code to be loaded into the current process, e.g. when using the JIT.
        """
        return _roadrunner.Compiler_getProcessTriple(self)

    def getHostCPUName(self) -> "std::string":
        r"""
        getHostCPUName - Get the LLVM name for the host CPU. The particular format
        of the name is target dependent, and suitable for passing as -mcpu to the
        target which matches the host.

        :rtype: string
        :return: - The host CPU name, or empty if the CPU could not be determined.
        """
        return _roadrunner.Compiler_getHostCPUName(self)

    def getVersion(self) -> "std::string":
        r"""get the version of the compiler."""
        return _roadrunner.Compiler_getVersion(self)

    @staticmethod
    def getDefaultCompiler() -> "std::string":
        return _roadrunner.Compiler_getDefaultCompiler()

    @staticmethod
    def New() -> "rr::Compiler *":
        return _roadrunner.Compiler_New()
    __swig_destroy__ = _roadrunner.delete_Compiler

# Register Compiler in _roadrunner:
_roadrunner.Compiler_swigregister(Compiler)

def Compiler_getDefaultCompiler() -> "std::string":
    return _roadrunner.Compiler_getDefaultCompiler()

def Compiler_New() -> "rr::Compiler *":
    return _roadrunner.Compiler_New()

class EventListener(object):
    r"""
    Notifies the user of SBML events
    RoadRunner has the capatiblity to notify user objects of any sbml event.

    In order to listen to sbml events, one simply implements the EventHandler
    interface and resgisters it with the ExecutableModel::setEventHandler method.

    To remove it, just pass in a 0.

    EventHanders are free to change any model parameters.

    They may return a result value specified by the Result enum. Currently, we
    we only have the HALT_SIMULATION which will result in RoadRunner::oneStep
    or RoadRunner::simulate to stop at the current time and return. This may be usefull
    if someone wants to run a simulation up until some threshold or state is reached.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    HALT_SIMULATION = _roadrunner.EventListener_HALT_SIMULATION

# Register EventListener in _roadrunner:
_roadrunner.EventListener_swigregister(EventListener)

class ExecutableModel(object):
    r"""
    Base class for all code generation systems; allows compiling
    and evaluating the model
    The ExecutableModel interface provides a way to access an
    sbml model that was compiled, JIT'd or interpreted
    as executable (runnable) module.

    An ExecutableModel holds a ModelData structure, all the simulation
    values are stored in the ModelData struct, i.e. the dynamic state
    of the model is fully contained in the ModelData structure.

    An ExecutableModel should also contain all of the initial conditions,
    rules, functions and whatever other semantic information that was
    specified in the sbml model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def getExecutableModelDesc(self) -> "std::string":
        return _roadrunner.ExecutableModel_getExecutableModelDesc(self)

    def getModelName(self) -> "std::string":
        r"""

        ExecutableModel.getModelName()

        Get the model name specified in the SBML.

        """
        return _roadrunner.ExecutableModel_getModelName(self)

    def setTime(self, _time: "double") -> "void":
        r"""

        ExecutableModel.setTime(time)

        Set the model time variable.

        :param time: time the time value to set.

        """
        return _roadrunner.ExecutableModel_setTime(self, _time)

    def getTime(self) -> "double":
        r"""

        ExecutableModel.getTime()

        Get the model time. The model originally start at time t=0 and is advaced forward in time by the
        integrator. So, if one ran a simulation from time = 0 to time = 10, the model will then have it's
        time = 10.

        """
        return _roadrunner.ExecutableModel_getTime(self)

    def getNumDepFloatingSpecies(self) -> "int":
        r"""
        dependent species are defined by rules and the only way to change them
        is by changing the values on which they depend.
        """
        return _roadrunner.ExecutableModel_getNumDepFloatingSpecies(self)

    def getNumFloatingSpecies(self) -> "int":
        r"""

        ExecutableModel.getNumFloatingSpecies()

        Returns the number of floating species in the model.

        """
        return _roadrunner.ExecutableModel_getNumFloatingSpecies(self)

    def getFloatingSpeciesId(self, index: "size_t") -> "std::string":
        return _roadrunner.ExecutableModel_getFloatingSpeciesId(self, index)

    def getNumIndFloatingSpecies(self) -> "int":
        r"""
        independent species do are not defined by rules, they typically participate
        in reactions and can have thier values set at any time.
        """
        return _roadrunner.ExecutableModel_getNumIndFloatingSpecies(self)

    def getNumBoundarySpecies(self) -> "int":
        r"""

        ExecutableModel.getNumBoundarySpecies()

        Returns the number of boundary species in the model.

        """
        return _roadrunner.ExecutableModel_getNumBoundarySpecies(self)

    def getBoundarySpeciesId(self, index: "size_t") -> "std::string":
        return _roadrunner.ExecutableModel_getBoundarySpeciesId(self, index)

    def setBoundarySpeciesAmounts(self, len: "size_t", values: "double const *") -> "int":
        return _roadrunner.ExecutableModel_setBoundarySpeciesAmounts(self, len, values)

    def setBoundarySpeciesInitConcentrations(self, len: "size_t", values: "double const *") -> "int":
        r"""
        Set the initial concentrations of the boundary species.

        Takes the same indices as the other boundary species methods.

        Note, if a boundary species has an initial assignment rule,
        than the initial conditions value can only be set by
        updating the values on which it depends, it can not be set
        directly.
        """
        return _roadrunner.ExecutableModel_setBoundarySpeciesInitConcentrations(self, len, values)

    def getBoundarySpeciesInitConcentrations(self, len: "size_t", values: "double *") -> "int":
        r"""
        Get the initial concentrations of the boundary species,
        uses the same indexing as the other boundary species methods.
        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesInitConcentrations(self, len, values)

    def setBoundarySpeciesInitAmounts(self, len: "size_t", values: "double const *") -> "int":
        r"""
        Set the initial amounts of the boundary species.

        Takes the same indices as the other boundary species methods.

        Note, if a boundary species has an initial assignment rule,
        than the initial conditions value can only be set by
        updating the values on which it depends, it can not be set
        directly.
        """
        return _roadrunner.ExecutableModel_setBoundarySpeciesInitAmounts(self, len, values)

    def getBoundarySpeciesInitAmounts(self, len: "size_t", values: "double *") -> "int":
        r"""
        Get the initial amounts of the boundary species,
        uses the same indexing as the other boundary species methods.
        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesInitAmounts(self, len, values)

    def getNumGlobalParameters(self) -> "int":
        r"""

        ExecutableModel.getNumGlobalParameters()


        Returns the number of global parameters in the model.

        """
        return _roadrunner.ExecutableModel_getNumGlobalParameters(self)

    def getGlobalParameterId(self, index: "size_t") -> "std::string":
        r"""id of the indexed global parameter."""
        return _roadrunner.ExecutableModel_getGlobalParameterId(self, index)

    def setGlobalParameterInitValues(self, len: "size_t", values: "double const *") -> "int":
        r"""
        Set the initial value of the global parameter.

        Takes the same indices as the other global parameter methods.
        """
        return _roadrunner.ExecutableModel_setGlobalParameterInitValues(self, len, values)

    def getGlobalParameterInitValues(self, len: "size_t", values: "double *") -> "int":
        r"""
        Get the initial amounts of the global parameter,
        uses the same indexing as the other global parameter methods.
        """
        return _roadrunner.ExecutableModel_getGlobalParameterInitValues(self, len, values)

    def getNumCompartments(self) -> "int":
        r"""

        ExecutableModel.getNumCompartments()

        Returns the number of compartments in the model.

        :rtype: int

        """
        return _roadrunner.ExecutableModel_getNumCompartments(self)

    def getCompartmentIndexForFloatingSpecies(self, index: "size_t") -> "int":
        return _roadrunner.ExecutableModel_getCompartmentIndexForFloatingSpecies(self, index)

    def getCompartmentIndexForBoundarySpecies(self, index: "size_t") -> "int":
        return _roadrunner.ExecutableModel_getCompartmentIndexForBoundarySpecies(self, index)

    def getCompartmentId(self, index: "size_t") -> "std::string":
        return _roadrunner.ExecutableModel_getCompartmentId(self, index)

    def getSupportedIdTypes(self) -> "int":
        r"""returns a bit field of the ids that this class supports."""
        return _roadrunner.ExecutableModel_getSupportedIdTypes(self)

    def getValue(self, id: "std::string const &") -> "double":
        r"""
        gets the value for the given id std::string. The std::string must be a SelectionRecord
        std::string that is accepted by this class.
        """
        return _roadrunner.ExecutableModel_getValue(self, id)

    def setValue(self, id: "std::string const &", value: "double") -> "void":
        r"""sets the value coresponding to the given selection stringl"""
        return _roadrunner.ExecutableModel_setValue(self, id, value)

    def getStoichiometry(self, speciesIndex: "int", reactionIndex: "int") -> "double":
        r"""

        ExecutableModel.getStoichiometry(speciesIndex, reactionIndex)

        Returns the stochiometric coefficient for the given species index and reaction index.

        Frequently one does not need the full stochiometrix matrix, particularly if the system is
        large and only a single coefficient is needed.


        :param speciesIndex: a floating species index from :meth:`getFloatingSpeciesIds`
        :param reactionIndex: a reaction index from :meth:`getReactionIds`


        Conserved Moieties
        ------------------

        """
        return _roadrunner.ExecutableModel_getStoichiometry(self, speciesIndex, reactionIndex)

    def getNumConservedMoieties(self) -> "int":
        r"""

        ExecutableModel.getNumConservedMoieties()

        Returns the number of conserved moieties in the model.

        :rtype: int

        """
        return _roadrunner.ExecutableModel_getNumConservedMoieties(self)

    def getConservedMoietyId(self, index: "size_t") -> "std::string":
        return _roadrunner.ExecutableModel_getConservedMoietyId(self, index)

    def getNumRateRules(self) -> "int":
        return _roadrunner.ExecutableModel_getNumRateRules(self)

    def getRateRuleSymbols(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Author: JKM
        07/31/2015
        Gets the symbols defined by rate rules, i.e.
        returns all x such that x' = f(x) is a rule which defines parameter x.
        """
        return _roadrunner.ExecutableModel_getRateRuleSymbols(self)

    def getNumReactions(self) -> "int":
        r"""

        ExecutableModel.getNumReactions()

        Returns the number of reactions in the model.

        """
        return _roadrunner.ExecutableModel_getNumReactions(self)

    def getStateVectorId(self, index: "size_t") -> "std::string":
        r"""get the id of an element of the state std::vector."""
        return _roadrunner.ExecutableModel_getStateVectorId(self, index)

    def getInfo(self) -> "std::string":
        r"""

        ExecutableModel.getInfo()

        get various info about the model.

        """
        return _roadrunner.ExecutableModel_getInfo(self)

    def getNumEvents(self) -> "int":
        return _roadrunner.ExecutableModel_getNumEvents(self)

    def applyEvents(self, timeEnd: "double", previousEventStatus: "unsigned char const *", initialState: "double const *", finalState: "double *") -> "int":
        r"""
        Itterate through all of the current and pending events and apply them. If any
        events trigger a state change which triggers any additional events, these
        are applied as well. After this method finishes, all events are processed.

        :type timeEnd: float
        :param timeEnd:: model time when the event occured.
        :type previousEventStatus: unsigned char
        :param previousEventStatus:: array of previous event triggered states.
        :type initialState: float
        :param initialState: (optional): initial state std::vector, may be NULL, in which
            the current state is used.
        :type finalState: float
        :param finalState: (optional): final state std::vector, where the final state is
            coppied to. May be NULL, in which case, ignored.
        """
        return _roadrunner.ExecutableModel_applyEvents(self, timeEnd, previousEventStatus, initialState, finalState)

    def getEventRoots(self, time: "double", y: "double const *", gdot: "double *") -> "void":
        r"""
        evaluate the event 'roots' -- when events transition form triggered - non-triggered
        or triggered to non-triggered state.

        Simplest method is to return 1 for triggered, -1 for not-triggered, so long
        as there is a zero crossing.

        :param time[in]: current time
        :param y[in]: the state std::vector
        :param gdot[out]: result event roots, this is of length numEvents.
        """
        return _roadrunner.ExecutableModel_getEventRoots(self, time, y, gdot)
    __swig_destroy__ = _roadrunner.delete_ExecutableModel

    def getEventIndex(self, eid: "std::string const &") -> "int":
        r"""
        Gets the index for an event id.
        If there is no event with this id, returns -1.
        """
        return _roadrunner.ExecutableModel_getEventIndex(self, eid)

    def getEventId(self, index: "size_t") -> "std::string":
        return _roadrunner.ExecutableModel_getEventId(self, index)

    def getAssignmentRuleIds(self, arg2: "std::list< std::string,std::allocator< std::string > > &") -> "void":
        return _roadrunner.ExecutableModel_getAssignmentRuleIds(self, arg2)

    def getRateRuleIds(self, arg2: "std::list< std::string,std::allocator< std::string > > &") -> "void":
        return _roadrunner.ExecutableModel_getRateRuleIds(self, arg2)

    def getInitialAssignmentIds(self, arg2: "std::list< std::string,std::allocator< std::string > > &") -> "void":
        return _roadrunner.ExecutableModel_getInitialAssignmentIds(self, arg2)

    def setEventListener(self, index: "size_t", eventHandler: "rr::EventListenerPtr") -> "void":
        return _roadrunner.ExecutableModel_setEventListener(self, index, eventHandler)

    def getEventListener(self, index: "size_t") -> "rr::EventListenerPtr":
        return _roadrunner.ExecutableModel_getEventListener(self, index)

    def getFloatingSpeciesAmountRate(self, index: "size_t", reactionRates: "double const *") -> "double":
        r"""
        Get the amount rate of change for the i'th floating species
        given a reaction rates std::vector.

        TODO: This should be merged with getFloatingSpeciesAmountRates, but that will
        break inteface, will do in next point release.

        TODO: If the conversion factor changes in between getting the
        reaction rates std::vector via getReactionRates

        :type index: int
        :param index:: index of the desired floating speceis rate.
        :type reactionRates: float
        :param reactionRates:: pointer to buffer of reaction rates.
        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesAmountRate(self, index, reactionRates)

    def reset(self, *args) -> "void":
        r"""

        ExecutableModel.reset()

        By default, reset all floating species concentrations and all variables changed by rate rules to their CURRENT init(X) values.

        It is possible to change the behavior of this function by providing a list of "or'ed" SelectionRecords.  For example, to reset only time and floating species, use:

        reset(SelectionRecord.TIME | SelectionRecord.FLOATING)

        The full list of recognized selection records are as follows.  These selection records are used by default:

        SelectionRecord.TIME:  Resets the time to zero.
        SelectionRecord.FLOATING:  Resets all floating species.
        SelectionRecord.RATE: Resets any variable or parameter that is changed by a rate rule (whether species, compartment, or parameter)

        The following selection records are added to the above when calling 'resetAll', and may be used separately or in concert with the above:

        SelectionRecord.BOUNDARY:  Resets the boundary species.
        SelectionRecord.COMPARTMENT:  Resets the compartments.
        SelectionRecord.GLOBAL_PARAMETER:  Resets the parameter objects.

        All of the above will use the current 'init(x)' values, and will re-calculate any initial assignments in the model based on the reset (or not reset) values they reference.  If one wishes to reset the model to its original state as defined in the SBML (resetting the 'init(x)' values as well), use:

        SelectionRecord.ALL:  Resets everything to as it was in the current SBML model.

        """
        return _roadrunner.ExecutableModel_reset(self, *args)

    def setRandomSeed(self, arg2: "int64_t") -> "void":
        r"""
        set the seed used by the random number generator. This will by definition
        reset the RNG.
        """
        return _roadrunner.ExecutableModel_setRandomSeed(self, arg2)

    def getRandomSeed(self) -> "int64_t":
        r"""get the seed used by the RNG."""
        return _roadrunner.ExecutableModel_getRandomSeed(self)

    def getRandom(self) -> "double":
        r"""
        Get a uniform random number between 0 and 1 created by the RNG.

        The type of RNG can be specified in the config file with the
        RANDOM_GENERATOR_TYPE key.
        """
        return _roadrunner.ExecutableModel_getRandom(self)

    def getFlags(self) -> "uint32_t":
        r"""Get the current set of flags"""
        return _roadrunner.ExecutableModel_getFlags(self)

    def setFlags(self, arg2: "uint32_t") -> "void":
        r"""
        Set certain options that determine the state of the ExecutableModel,
        these are listed in
        """
        return _roadrunner.ExecutableModel_setFlags(self, arg2)
    INTEGRATION = _roadrunner.ExecutableModel_INTEGRATION
    r"""
    A simulation is currently running. This means that the model
    should not have to re-calculate the reaction rate std::vector
    as it was calculated in the previous integration step.
    """
    OPTIMIZE_REACTION_RATE_SELECTION = _roadrunner.ExecutableModel_OPTIMIZE_REACTION_RATE_SELECTION
    r"""optimize not-recalculating the reaction rates during selection."""

    def setIntegrationStartTime(self, time: "double") -> "void":
        return _roadrunner.ExecutableModel_setIntegrationStartTime(self, time)

    def getIds(self, types: "int") -> "PyObject *":
        r"""
        creates a function signature of
        SWIGINTERN PyObject *rr_ExecutableModel_getIds(rr::ExecutableModel *self,int types);
        """
        return _roadrunner.ExecutableModel_getIds(self, types)

    def getEventIds(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getEventIds()

        Returns a list of event ids.

        :returns: a list of event ids.


        Misc
        ----

        """
        return _roadrunner.ExecutableModel_getEventIds(self, *args)

    def getFloatingSpeciesAmounts(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesAmounts([index])

        Get the list of floating species amounts. If no arguments are given, this
        returns all floating species amounts.

        :param index: an optional array of desired floating species indices. i.e. if this model has
                      4 floating species and we want the amounts for the last and first, we
                      would use [3,0] for the index array.
        :type name: numpy.ndarray

        get all the amounts::

          >>> e.getFloatingSpeciesAmounts()
          [15,2,3,20]

        get amounts 3 and 0::

          >>> getFloatingSpeciesAmounts([3,0])
          [10,15]

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesAmounts(self, *args)

    def getFloatingSpeciesConcentrationRates(self, *args) -> "PyObject *":
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrationRates(self, *args)

    def getFloatingSpeciesConcentrations(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesConcentrations([index])

        Returns a vector of floating species concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species concentrations.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrations(self, *args)

    def getBoundarySpeciesAmounts(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getBoundarySpeciesAmounts([index])

        Returns a vector of boundary species amounts. The order of species is
        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species amounts.
        :rtype: numpy.ndarray.

        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species amounts.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesAmounts(self, *args)

    def getBoundarySpeciesConcentrations(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getBoundarySpeciesConcentrations([index])

        Returns a vector of boundary species concentrations. The order of species is
        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species concentrations.
        :rtype: numpy.ndarray.

        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species concentrations.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesConcentrations(self, *args)

    def getGlobalParameterValues(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getGlobalParameterValues([index])

        Return a vector of global parameter values. The order of species is
        given by the order of Ids returned by getGlobalParameterIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of global parameter values.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getGlobalParameterValues(self, *args)

    def getCompartmentVolumes(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getCompartmentVolumes([index])

        Returns a vector of compartment volumes. The order of volumes is
        given by the order of Ids returned by getCompartmentIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of compartment volumes.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getCompartmentVolumes(self, *args)

    def getConservedMoietyValues(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getConservedMoietyValues([index])

        Returns a vector of conserved moiety volumes. The order of values is
        given by the order of Ids returned by getConservedMoietyIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of conserved moiety values.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getConservedMoietyValues(self, *args)

    def getReactionRates(self, *args) -> "PyObject *":
        r"""

        ExecutableModel.getReactionRates([index])

        Returns a vector of reaction rates (reaction velocity) for the current state of the model. The
        order of reaction rates is given by the order of Ids returned by getReactionIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of reaction rates.
        :rtype: numpy.ndarray



        Stoichiometry
        -------------

        """
        return _roadrunner.ExecutableModel_getReactionRates(self, *args)

    def getFloatingSpeciesInitConcentrations(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesInitConcentrations([index])

        Returns a vector of floating species initial concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialConcentrationIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species initial concentrations.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitConcentrations(self)

    def getFloatingSpeciesInitAmounts(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesInitAmounts([index])

        Returns a vector of floating species initial amounts. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialConcentrationIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species initial amounts.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitAmounts(self)

    def getCompartmentInitVolumes(self) -> "PyObject *":
        return _roadrunner.ExecutableModel_getCompartmentInitVolumes(self)

    def getFloatingSpeciesIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesIds()

        Return a list of floating species sbml ids.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesIds(self)

    def getFloatingSpeciesConcentrationIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesConcentrationIds()

        Return a list of floating species concentration ids.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrationIds(self)

    def getBoundarySpeciesIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getBoundarySpeciesIds()

        Returns a vector of boundary species Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of boundary species ids.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesIds(self)

    def getBoundarySpeciesConcentrationIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getBoundarySpeciesConcentrationIds()

        Returns a vector of boundary species concentration Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of boundary species ids.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesConcentrationIds(self)

    def getGlobalParameterIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getGlobalParameterIds([index])

        Return a list of global parameter ids.

        :returns: a list of global parameter ids.

        """
        return _roadrunner.ExecutableModel_getGlobalParameterIds(self)

    def getCompartmentIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getCompartmentIds([index])

        Returns a vector of compartment identifier symbols.

        :param index: A array of compartment indices indicating which compartment ids to return.
        :type index: None or numpy.ndarray
        :returns: a list of compartment ids.

        """
        return _roadrunner.ExecutableModel_getCompartmentIds(self)

    def getConservedMoietyIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getConservedMoietyIds([index])

        Returns a vector of conserved moiety identifier symbols.


        :param index: A array of compartment indices indicating which compartment ids to return.
        :type index: None or numpy.ndarray
        :returns: a list of compartment ids.

        """
        return _roadrunner.ExecutableModel_getConservedMoietyIds(self)

    def getReactionIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getReactionIds()

        Returns a vector of reaction Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of reaction ids.

        """
        return _roadrunner.ExecutableModel_getReactionIds(self)

    def getFloatingSpeciesInitAmountIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesInitAmountIds()

        get a list of the floating species amount initial amount selection symbols.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitAmountIds(self)

    def getFloatingSpeciesInitConcentrationIds(self) -> "PyObject *":
        r"""

        ExecutableModel.getFloatingSpeciesInitConcentrationIds()

        get a list of the floating species amount initial concentration selection symbols.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitConcentrationIds(self)

    def getAllTimeCourseComponentIds(self):
        """

        ExecutableModel.getAllTimeCourseComponentIds([index])

        Return a list of all component ids. The list includes ids of amount/concentration of
        floating species, boundary species, global parameters, compartments, and reactions, as well as `time`.

        :returns: a list of all component ids widely used in time course selections.

        """

        return (['time'] + self.getFloatingSpeciesIds() + self.getBoundarySpeciesIds()
        + self.getFloatingSpeciesConcentrationIds() + self.getBoundarySpeciesConcentrationIds()
        + self.getGlobalParameterIds() + self.getCompartmentIds() + self.getReactionIds())


    def setFloatingSpeciesAmounts(self, *args) -> "int":
        r"""

        ExecutableModel.setFloatingSpeciesAmounts([index], values)

        Use this to set the entire set of floating species amounts in one call.
        The order of species is given by the order of Ids returned by getFloatingSpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be
                                    an array of all the values to set.
        :param numpy.ndarray values: the values to set.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesAmounts(self, *args)

    def setFloatingSpeciesConcentrations(self, *args) -> "int":
        r"""

        ExecutableModel.setFloatingSpeciesConcentrations([index], values)

        Use this to set the entire set of floating species concentrations in one call.
        The order of species is given by the order of Ids returned by getFloatingSpeciesIds()


        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.
        :param numpy.ndarray values: the values to set.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesConcentrations(self, *args)

    def setBoundarySpeciesConcentrations(self, *args) -> "int":
        r"""

        ExecutableModel.setBoundarySpeciesConcentrations([index], values)

        Use this to set the entire set of boundary species concentrations in one call.
        The order of species is given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.

        :param numpy.ndarray values: the values to set.

        Compartments
        ------------

        """
        return _roadrunner.ExecutableModel_setBoundarySpeciesConcentrations(self, *args)

    def setGlobalParameterValues(self, *args) -> "int":
        r"""

        ExecutableModel.setGlobalParameterValues([index], values)

        Use this to set the entire set of global parameters in one call.
        The order of parameters is given by the order of Ids returned by getGlobalParameterIds()


        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the values to set.
        :param numpy.ndarray values: the values to set.

        Reactions
        ---------

        """
        return _roadrunner.ExecutableModel_setGlobalParameterValues(self, *args)

    def setCompartmentVolumes(self, *args) -> "int":
        r"""

        ExecutableModel.setCompartmentVolumes([index], values)

        Sets a vector of compartment volumes.

        If the index vector is not give, then the values vector treated as a vector of all
        compartment volumes to set. If index is given, then  values should have the same
        length as index.

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.

        :param numpy.ndarray values: the values to set.



        Global Parameters
        -----------------

        """
        return _roadrunner.ExecutableModel_setCompartmentVolumes(self, *args)

    def setConservedMoietyValues(self, *args) -> "int":
        r"""

        ExecutableModel.setConservedMoietyValues([index], values)

        Sets a vector of conserved moiety values.

        *Note* This method currently only updates the conserved moiety values, it does
        not update the initial species condition from which the values were calculated.

        If the index vector is not given, then the values vector treated as a vector of all
        values to set. If index is given, then  values should have the same
        length as index.

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.
        :param numpy.ndarray values: the values to set.



        Events
        ------------------

        """
        return _roadrunner.ExecutableModel_setConservedMoietyValues(self, *args)

    def setFloatingSpeciesInitConcentrations(self, *args) -> "int":
        r"""

        ExecutableModel.setFloatingSpeciesInitConcentrations([index], values)

        Set a vector of floating species initial concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialAmountIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesInitConcentrations(self, *args)

    def setFloatingSpeciesInitAmounts(self, *args) -> "int":
        r"""

        ExecutableModel.setFloatingSpeciesInitAmounts([index], values)

        Set a vector of floating species initial amounts. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialAmountIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.




        Boundary Species
        ----------------

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesInitAmounts(self, *args)

    def setCompartmentInitVolumes(self, *args) -> "int":
        return _roadrunner.ExecutableModel_setCompartmentInitVolumes(self, *args)

    def getCurrentStoichiometryMatrix(self) -> "PyObject *":
        return _roadrunner.ExecutableModel_getCurrentStoichiometryMatrix(self)

    def __getitem__(self, id: "std::string const &") -> "double":
        r"""get values."""
        return _roadrunner.ExecutableModel___getitem__(self, id)

    def __setitem__(self, id: "std::string const &", value: "double") -> "void":
        return _roadrunner.ExecutableModel___setitem__(self, id, value)

    def __repr__(self) -> "std::string":
        return _roadrunner.ExecutableModel___repr__(self)

    def getEvent(self, *args) -> "rr::PyEventListener *":
        return _roadrunner.ExecutableModel_getEvent(self, *args)


    def keys(self, types=_roadrunner.SelectionRecord_ALL):
        return self.getIds(types)

    def values(self, types=_roadrunner.SelectionRecord_ALL):
        return [self.getValue(k) for k in self.keys(types)]

    def items(self, types=_roadrunner.SelectionRecord_ALL):
        return [(k, self.getValue(k)) for k in self.keys(types)]

    def __len__(self):
        return len(self.keys())

    def iteritems(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over (key, value) pairs
        """
        return self.items(types).__iter__()

    def iterkeys(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's keys
        """
        return self.keys(types).__iter__()

    def itervalues(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's values
        """
        return self.values(types).__iter__()


# Register ExecutableModel in _roadrunner:
_roadrunner.ExecutableModel_swigregister(ExecutableModel)

class ExecutableModelFactory(object):
    r"""A factory class to create ExecutableModel objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createModel(*args) -> "rr::ExecutableModel *":
        return _roadrunner.ExecutableModelFactory_createModel(*args)

    @staticmethod
    def regenerateModel(oldModel: "ExecutableModel", doc: "libsbml::SBMLDocument *", options: "uint") -> "rr::ExecutableModel *":
        return _roadrunner.ExecutableModelFactory_regenerateModel(oldModel, doc, options)

    def __init__(self):
        _roadrunner.ExecutableModelFactory_swiginit(self, _roadrunner.new_ExecutableModelFactory())
    __swig_destroy__ = _roadrunner.delete_ExecutableModelFactory

# Register ExecutableModelFactory in _roadrunner:
_roadrunner.ExecutableModelFactory_swigregister(ExecutableModelFactory)

def ExecutableModelFactory_createModel(*args) -> "rr::ExecutableModel *":
    return _roadrunner.ExecutableModelFactory_createModel(*args)

def ExecutableModelFactory_regenerateModel(oldModel: "ExecutableModel", doc: "libsbml::SBMLDocument *", options: "uint") -> "rr::ExecutableModel *":
    return _roadrunner.ExecutableModelFactory_regenerateModel(oldModel, doc, options)

VERSIONSTR_BASIC = _roadrunner.VERSIONSTR_BASIC
r'''the basic version std::string, i.e. "1.0.0"'''
VERSIONSTR_COMPILER = _roadrunner.VERSIONSTR_COMPILER
r"""the compiler std::string"""
VERSIONSTR_DATE = _roadrunner.VERSIONSTR_DATE
r"""when roadrunner was compiled"""
VERSIONSTR_LIBSBML = _roadrunner.VERSIONSTR_LIBSBML
r"""the version of libSBML we're using"""
VERSIONSTR_JITCOMPILER = _roadrunner.VERSIONSTR_JITCOMPILER
VERSIONSTR_GIT_BRANCH = _roadrunner.VERSIONSTR_GIT_BRANCH
r"""what git branch we are on."""
VERSIONSTR_GIT_COMMIT = _roadrunner.VERSIONSTR_GIT_COMMIT
r"""the last commit."""

def getVersionStr(*args, **kwargs) -> "std::string":
    r"""
    get the roadrunner version std::string.

    The options can be any set of the values from the VersionStrOptions enum.

    Each one of these options are concatenated into the output std::string and there
    are ';' separators between each of them.
    """
    return _roadrunner.getVersionStr(*args, **kwargs)

def getCopyrightStr() -> "std::string":
    r"""get the copyright std::string."""
    return _roadrunner.getCopyrightStr()
class Logger(object):
    r"""
    The roadrunner logger.

    A set of static method for setting the logging level.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LOG_CURRENT = _roadrunner.Logger_LOG_CURRENT
    r"""


    Use the current level -- don't change the level from what it is.

    """
    LOG_FATAL = _roadrunner.Logger_LOG_FATAL
    r"""


    A fatal error. The application will most likely terminate. This is the highest priority.

    """
    LOG_CRITICAL = _roadrunner.Logger_LOG_CRITICAL
    r"""


    A critical error. The application might not be able to continue running successfully.

    """
    LOG_ERROR = _roadrunner.Logger_LOG_ERROR
    r"""


    An error. An operation did not complete successfully, but the application as a whole is not affected.

    """
    LOG_WARNING = _roadrunner.Logger_LOG_WARNING
    r"""


    A warning. An operation completed with an unexpected result.

    """
    LOG_NOTICE = _roadrunner.Logger_LOG_NOTICE
    r"""


    A notice, which is an information with just a higher priority.

    """
    LOG_INFORMATION = _roadrunner.Logger_LOG_INFORMATION
    r"""


    An informational message, usually denoting the successful completion of an operation.

    """
    LOG_DEBUG = _roadrunner.Logger_LOG_DEBUG
    r"""


    A debugging message.

    """
    LOG_TRACE = _roadrunner.Logger_LOG_TRACE
    r"""


    A tracing message. This is the lowest priority.

    Logging Methods
    ---------------

    """

    @staticmethod
    def setLevel(*args, **kwargs) -> "void":
        r"""

        Logger.setLevel([level])

        sets the logging level to one a value from Logger::Level

        :param int level: the level to set, defaults to LOG_CURRENT if none is specified.

        """
        return _roadrunner.Logger_setLevel(*args, **kwargs)

    @staticmethod
    def getLevel() -> "int":
        r"""

        Logger.getLevel()

        get the current logging level.

        """
        return _roadrunner.Logger_getLevel()

    @staticmethod
    def disableLogging() -> "void":
        r"""

        Logger.disableLogging()

        Suppresses all logging output

        """
        return _roadrunner.Logger_disableLogging()

    @staticmethod
    def disableConsoleLogging() -> "void":
        r"""

        Logger.disableConsoleLogging()

        stops logging to the console, but file logging may continue.

        """
        return _roadrunner.Logger_disableConsoleLogging()

    @staticmethod
    def enableConsoleLogging(*args, **kwargs) -> "void":
        r"""

        Logger.enableConsoleLogging(level)

        turns on console logging (stderr) at the given level.

        :param level: A logging level, one of the above listed LOG_* levels.

        """
        return _roadrunner.Logger_enableConsoleLogging(*args, **kwargs)

    @staticmethod
    def enableFileLogging(*args, **kwargs) -> "void":
        r"""

        Logger.enableFileLogging(fileName, [level])

        turns on file logging to the given file as the given level.

        :param str fileName: the path of a file to log to.
        :param level: (optional) the logging level, defaults to LOG_CURRENT.

        """
        return _roadrunner.Logger_enableFileLogging(*args, **kwargs)

    @staticmethod
    def disableFileLogging() -> "void":
        r"""

        Logger.disableFileLogging()

        turns off file logging, but has no effect on console logging.

        """
        return _roadrunner.Logger_disableFileLogging()

    @staticmethod
    def getCurrentLevelAsString() -> "std::string":
        r"""

        Logger.getCurrentLevelAsString()

        get the textural form of the current logging level.

        """
        return _roadrunner.Logger_getCurrentLevelAsString()

    @staticmethod
    def getFileName() -> "std::string":
        r"""

        Logger.getFileName()

        get the name of the currently used log file.

        """
        return _roadrunner.Logger_getFileName()

    @staticmethod
    def setFormattingPattern(format: "std::string const &") -> "void":
        r"""

        Logger.setFormattingPattern(format)

        Internally, RoadRunner uses the Poco logging framework, so we
        can custom format logging output based on a formatting pattern
        string.

        The format pattern is used as a template to format the message and
        is copied character by character except for the following special characters,
        which are replaced by the corresponding value.

        An example pattern of "%Y-%m-%d %H:%M:%S %p: %t" set via::

          roadrunner.Logger.setFormattingPattern("%Y-%m-%d %H:%M:%S %p: %t")

        would produce the following output:

        .. image:: logging2.png

        |

        RoadRunner supports the following format specifiers. These were copied from the Poco documentation:

        * %s - message source
        * %t - message text
        * %l - message priority level (1 .. 7)
        * %p - message priority (Fatal, Critical, Error, Warning, Notice, Information, Debug, Trace)
        * %q - abbreviated message priority (F, C, E, W, N, I, D, T)
        * %P - message process identifier
        * %T - message thread name
        * %I - message thread identifier (numeric)
        * %N - node or host name
        * %U - message source file path (empty string if not set)
        * %u - message source line number (0 if not set)
        * %w - message date/time abbreviated weekday (Mon, Tue, ...)
        * %W - message date/time full weekday (Monday, Tuesday, ...)
        * %b - message date/time abbreviated month (Jan, Feb, ...)
        * %B - message date/time full month (January, February, ...)
        * %d - message date/time zero-padded day of month (01 .. 31)
        * %e - message date/time day of month (1 .. 31)
        * %f - message date/time space-padded day of month ( 1 .. 31)
        * %m - message date/time zero-padded month (01 .. 12)
        * %n - message date/time month (1 .. 12)
        * %o - message date/time space-padded month ( 1 .. 12)
        * %y - message date/time year without century (70)
        * %Y - message date/time year with century (1970)
        * %H - message date/time hour (00 .. 23)
        * %h - message date/time hour (00 .. 12)
        * %a - message date/time am/pm
        * %A - message date/time AM/PM
        * %M - message date/time minute (00 .. 59)
        * %S - message date/time second (00 .. 59)
        * %i - message date/time millisecond (000 .. 999)
        * %c - message date/time centisecond (0 .. 9)
        * %F - message date/time fractional seconds/microseconds (000000 - 999999)
        * %z - time zone differential in ISO 8601 format (Z or +NN.NN)
        * %Z - time zone differential in RFC format (GMT or +NNNN)
        * %E - epoch time (UTC, seconds since midnight, January 1, 1970)
        * %[name] - the value of the message parameter with the given name
        * %% - percent sign

        :param str format: the logging format string. Must be formatted using the above specifiers.

        """
        return _roadrunner.Logger_setFormattingPattern(format)

    @staticmethod
    def getFormattingPattern() -> "std::string":
        r"""

        Logger.getFormattingPattern()

        get the currently set formatting pattern.

        """
        return _roadrunner.Logger_getFormattingPattern()

    @staticmethod
    def levelToString(level: "int") -> "std::string":
        r"""

        Logger.levelToString(level)

        gets the textual form of a logging level Enum for a given value.

        :param int level: One of the above listed logging levels.

        """
        return _roadrunner.Logger_levelToString(level)

    @staticmethod
    def stringToLevel(str: "std::string const &") -> "rr::Logger::Level":
        r"""

        Logger.stringToLevel(s)

        parses a string and returns a Logger::Level

        :param str s: the string to parse.

        """
        return _roadrunner.Logger_stringToLevel(str)

    @staticmethod
    def getColoredOutput() -> "bool":
        r"""

        Logger.getColoredOutput()

        check if we have colored logging enabled.

        """
        return _roadrunner.Logger_getColoredOutput()

    @staticmethod
    def setColoredOutput(arg1: "bool") -> "void":
        r"""

        Logger.setColoredOutput(b)

        enable / disable colored output

        :param boolean b: turn colored logging on or off

        """
        return _roadrunner.Logger_setColoredOutput(arg1)

    @staticmethod
    def setProperty(name: "std::string const &", value: "std::string const &") -> "void":
        r"""

        Logger.setProperty(name, value)

        Set the color of the output logging messages.

        In the future, we may add additional properties here.

        The following properties are supported:

        * enableColors:      Enable or disable colors.
        * traceColor:        Specify color for trace messages.
        * debugColor:        Specify color for debug messages.
        * informationColor:  Specify color for information messages.
        * noticeColor:       Specify color for notice messages.
        * warningColor:      Specify color for warning messages.
        * errorColor:        Specify color for error messages.
        * criticalColor:     Specify color for critical messages.
        * fatalColor:        Specify color for fatal messages.


        The following color values are supported:

        * default
        * black
        * red
        * green
        * brown
        * blue
        * magenta
        * cyan
        * gray
        * darkgray
        * lightRed
        * lightGreen
        * yellow
        * lightBlue
        * lightMagenta
        * lightCyan
        * white

        :param str name: the name of the value to set.
        :param str value: the value to set.

        """
        return _roadrunner.Logger_setProperty(name, value)

    @staticmethod
    def log(level: "rr::Logger::Level", msg: "std::string const &") -> "void":
        r"""

        Logger.log(level, msg)

        logs a message to the log.

        :param int level: the level to log at.
        :param str msg: the message to log.

        """
        return _roadrunner.Logger_log(level, msg)

    @staticmethod
    def enablePythonLogging() -> "void":
        return _roadrunner.Logger_enablePythonLogging()

    @staticmethod
    def disablePythonLogging() -> "void":
        return _roadrunner.Logger_disablePythonLogging()

    def __init__(self):
        _roadrunner.Logger_swiginit(self, _roadrunner.new_Logger())
    __swig_destroy__ = _roadrunner.delete_Logger

# Register Logger in _roadrunner:
_roadrunner.Logger_swigregister(Logger)

def Logger_setLevel(*args, **kwargs) -> "void":
    r"""

    Logger.setLevel([level])

    sets the logging level to one a value from Logger::Level

    :param int level: the level to set, defaults to LOG_CURRENT if none is specified.

    """
    return _roadrunner.Logger_setLevel(*args, **kwargs)

def Logger_getLevel() -> "int":
    r"""

    Logger.getLevel()

    get the current logging level.

    """
    return _roadrunner.Logger_getLevel()

def Logger_disableLogging() -> "void":
    r"""

    Logger.disableLogging()

    Suppresses all logging output

    """
    return _roadrunner.Logger_disableLogging()

def Logger_disableConsoleLogging() -> "void":
    r"""

    Logger.disableConsoleLogging()

    stops logging to the console, but file logging may continue.

    """
    return _roadrunner.Logger_disableConsoleLogging()

def Logger_enableConsoleLogging(*args, **kwargs) -> "void":
    r"""

    Logger.enableConsoleLogging(level)

    turns on console logging (stderr) at the given level.

    :param level: A logging level, one of the above listed LOG_* levels.

    """
    return _roadrunner.Logger_enableConsoleLogging(*args, **kwargs)

def Logger_enableFileLogging(*args, **kwargs) -> "void":
    r"""

    Logger.enableFileLogging(fileName, [level])

    turns on file logging to the given file as the given level.

    :param str fileName: the path of a file to log to.
    :param level: (optional) the logging level, defaults to LOG_CURRENT.

    """
    return _roadrunner.Logger_enableFileLogging(*args, **kwargs)

def Logger_disableFileLogging() -> "void":
    r"""

    Logger.disableFileLogging()

    turns off file logging, but has no effect on console logging.

    """
    return _roadrunner.Logger_disableFileLogging()

def Logger_getCurrentLevelAsString() -> "std::string":
    r"""

    Logger.getCurrentLevelAsString()

    get the textural form of the current logging level.

    """
    return _roadrunner.Logger_getCurrentLevelAsString()

def Logger_getFileName() -> "std::string":
    r"""

    Logger.getFileName()

    get the name of the currently used log file.

    """
    return _roadrunner.Logger_getFileName()

def Logger_setFormattingPattern(format: "std::string const &") -> "void":
    r"""

    Logger.setFormattingPattern(format)

    Internally, RoadRunner uses the Poco logging framework, so we
    can custom format logging output based on a formatting pattern
    string.

    The format pattern is used as a template to format the message and
    is copied character by character except for the following special characters,
    which are replaced by the corresponding value.

    An example pattern of "%Y-%m-%d %H:%M:%S %p: %t" set via::

      roadrunner.Logger.setFormattingPattern("%Y-%m-%d %H:%M:%S %p: %t")

    would produce the following output:

    .. image:: logging2.png

    |

    RoadRunner supports the following format specifiers. These were copied from the Poco documentation:

    * %s - message source
    * %t - message text
    * %l - message priority level (1 .. 7)
    * %p - message priority (Fatal, Critical, Error, Warning, Notice, Information, Debug, Trace)
    * %q - abbreviated message priority (F, C, E, W, N, I, D, T)
    * %P - message process identifier
    * %T - message thread name
    * %I - message thread identifier (numeric)
    * %N - node or host name
    * %U - message source file path (empty string if not set)
    * %u - message source line number (0 if not set)
    * %w - message date/time abbreviated weekday (Mon, Tue, ...)
    * %W - message date/time full weekday (Monday, Tuesday, ...)
    * %b - message date/time abbreviated month (Jan, Feb, ...)
    * %B - message date/time full month (January, February, ...)
    * %d - message date/time zero-padded day of month (01 .. 31)
    * %e - message date/time day of month (1 .. 31)
    * %f - message date/time space-padded day of month ( 1 .. 31)
    * %m - message date/time zero-padded month (01 .. 12)
    * %n - message date/time month (1 .. 12)
    * %o - message date/time space-padded month ( 1 .. 12)
    * %y - message date/time year without century (70)
    * %Y - message date/time year with century (1970)
    * %H - message date/time hour (00 .. 23)
    * %h - message date/time hour (00 .. 12)
    * %a - message date/time am/pm
    * %A - message date/time AM/PM
    * %M - message date/time minute (00 .. 59)
    * %S - message date/time second (00 .. 59)
    * %i - message date/time millisecond (000 .. 999)
    * %c - message date/time centisecond (0 .. 9)
    * %F - message date/time fractional seconds/microseconds (000000 - 999999)
    * %z - time zone differential in ISO 8601 format (Z or +NN.NN)
    * %Z - time zone differential in RFC format (GMT or +NNNN)
    * %E - epoch time (UTC, seconds since midnight, January 1, 1970)
    * %[name] - the value of the message parameter with the given name
    * %% - percent sign

    :param str format: the logging format string. Must be formatted using the above specifiers.

    """
    return _roadrunner.Logger_setFormattingPattern(format)

def Logger_getFormattingPattern() -> "std::string":
    r"""

    Logger.getFormattingPattern()

    get the currently set formatting pattern.

    """
    return _roadrunner.Logger_getFormattingPattern()

def Logger_levelToString(level: "int") -> "std::string":
    r"""

    Logger.levelToString(level)

    gets the textual form of a logging level Enum for a given value.

    :param int level: One of the above listed logging levels.

    """
    return _roadrunner.Logger_levelToString(level)

def Logger_stringToLevel(str: "std::string const &") -> "rr::Logger::Level":
    r"""

    Logger.stringToLevel(s)

    parses a string and returns a Logger::Level

    :param str s: the string to parse.

    """
    return _roadrunner.Logger_stringToLevel(str)

def Logger_getColoredOutput() -> "bool":
    r"""

    Logger.getColoredOutput()

    check if we have colored logging enabled.

    """
    return _roadrunner.Logger_getColoredOutput()

def Logger_setColoredOutput(arg1: "bool") -> "void":
    r"""

    Logger.setColoredOutput(b)

    enable / disable colored output

    :param boolean b: turn colored logging on or off

    """
    return _roadrunner.Logger_setColoredOutput(arg1)

def Logger_setProperty(name: "std::string const &", value: "std::string const &") -> "void":
    r"""

    Logger.setProperty(name, value)

    Set the color of the output logging messages.

    In the future, we may add additional properties here.

    The following properties are supported:

    * enableColors:      Enable or disable colors.
    * traceColor:        Specify color for trace messages.
    * debugColor:        Specify color for debug messages.
    * informationColor:  Specify color for information messages.
    * noticeColor:       Specify color for notice messages.
    * warningColor:      Specify color for warning messages.
    * errorColor:        Specify color for error messages.
    * criticalColor:     Specify color for critical messages.
    * fatalColor:        Specify color for fatal messages.


    The following color values are supported:

    * default
    * black
    * red
    * green
    * brown
    * blue
    * magenta
    * cyan
    * gray
    * darkgray
    * lightRed
    * lightGreen
    * yellow
    * lightBlue
    * lightMagenta
    * lightCyan
    * white

    :param str name: the name of the value to set.
    :param str value: the value to set.

    """
    return _roadrunner.Logger_setProperty(name, value)

def Logger_log(level: "rr::Logger::Level", msg: "std::string const &") -> "void":
    r"""

    Logger.log(level, msg)

    logs a message to the log.

    :param int level: the level to log at.
    :param str msg: the message to log.

    """
    return _roadrunner.Logger_log(level, msg)

def Logger_enablePythonLogging() -> "void":
    return _roadrunner.Logger_enablePythonLogging()

def Logger_disablePythonLogging() -> "void":
    return _roadrunner.Logger_disablePythonLogging()

class RoadRunner(object):
    r"""

    RoadRunner.__init__(uriOrSBML = , options = None)

    Creates a new RoadRunner object. If the first argument is specified,
    it should be a string containing either the contents of an SBML document,
    or a formatted URI specifying the path or location of a SBML document.

    If options is given, it should be a LoadSBMLOptions object.

    If no arguments are given, a document may be loaded at any future time
    using the load method.

    :param uriOrSBML: a URI, local path or SBML document contents.
    :type name: str (optional)

    :param options: (LoadSBMLOptions) an options object specifying how the
                    SBML document should be loaded
    :type name: str (optional)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        *Overload 1:*

        create an empty RoadRunner object with given SBML level and version.

        |

        *Overload 2:*

        load an sbml document from anywhere.

        same arguments as load.

        If options is not null, then the RoadRunner::computeAndAssignConservationLaws
        flag is set to whatever value is specified in the options struct.

        :type uriOrSBML: string
        :param uriOrSBML:: a URI, local path or sbml document contents.
        :type options: :py:class:`Dictionary`, optional
        :param options:: an options struct, if null, default values are used.

        |

        *Overload 3:*

        RoadRunner copy constructor
        Explicitly defined because of Python.
        """
        _roadrunner.RoadRunner_swiginit(self, _roadrunner.new_RoadRunner(*args))
    __swig_destroy__ = _roadrunner.delete_RoadRunner

    def getInstanceID(self) -> "int":
        r"""

        RoadRunner.getInstanceID()

        When there are multiple instances of RoadRunner, this is the instance id.

        """
        return _roadrunner.RoadRunner_getInstanceID(self)

    def getInstanceCount(self) -> "int":
        r"""

        RoadRunner.getInstanceCount()

        Number of currently running RoadRunner instances.

        """
        return _roadrunner.RoadRunner_getInstanceCount(self)

    @staticmethod
    def getParamPromotedSBML(sArg: "std::string const &") -> "std::string":
        r"""

        RoadRunner.getParamPromotedSBML(*args)

        Takes an SBML document or path to an SBML document and changes all of the local parameters
        to be global parameters.

        :param str SBML: the contents or path to an SBML document
        :rtype: str

        """
        return _roadrunner.RoadRunner_getParamPromotedSBML(sArg)

    def getInfo(self) -> "std::string":
        r"""

        RoadRunner.getInfo()

        return info about the current state of the object

        :rtype: str

        """
        return _roadrunner.RoadRunner_getInfo(self)

    def getCurrentTime(self) -> "double":
        r"""return the current time as a double"""
        return _roadrunner.RoadRunner_getCurrentTime(self)

    def getCompiler(self) -> "rr::Compiler *":
        r"""

        RoadRunner.getCompiler()

        Return the JIT :class:`Compiler` object currently being used.
        This object provides various information about the current processor and system.

        """
        return _roadrunner.RoadRunner_getCompiler(self)

    def getIntegrator(self) -> "rr::Integrator *":
        r"""

        RoadRunner.getIntegrator()

        get the integrator which is currently being used to
        time evolve the system.

        """
        return _roadrunner.RoadRunner_getIntegrator(self)

    def getSteadyStateSolver(self) -> "rr::SteadyStateSolver *":
        r"""get a pointer to the current steady state solver"""
        return _roadrunner.RoadRunner_getSteadyStateSolver(self)

    def getSensitivitySolver(self) -> "rr::SensitivitySolver *":
        r"""get a pointer to the current sensitivities solver"""
        return _roadrunner.RoadRunner_getSensitivitySolver(self)

    def getIntegratorByName(self, name: "std::string const &") -> "rr::Integrator *":
        r"""Get an integrator by name without switching the current integrator"""
        return _roadrunner.RoadRunner_getIntegratorByName(self, name)

    def getSteadyStateSolverByName(self, name: "std::string const &") -> "rr::SteadyStateSolver *":
        r"""Get an SteadyStateSolver by name without switching the current solver"""
        return _roadrunner.RoadRunner_getSteadyStateSolverByName(self, name)

    def getSensitivitySolverByName(self, name: "std::string const &") -> "rr::SensitivitySolver *":
        r"""Get an SensitivitySolver by name without switching the current solver"""
        return _roadrunner.RoadRunner_getSensitivitySolverByName(self, name)

    def makeIntegrator(self, name: "std::string const &") -> "rr::Integrator *":
        r"""Make an integrator for the given name"""
        return _roadrunner.RoadRunner_makeIntegrator(self, name)

    def makeSteadyStateSolver(self, name: "std::string const &") -> "rr::SteadyStateSolver *":
        r"""Make an SteadyStateSolver* for the given name"""
        return _roadrunner.RoadRunner_makeSteadyStateSolver(self, name)

    def makeSensitivitySolver(self, name: "std::string const &") -> "rr::SensitivitySolver *":
        r"""Make SensitivitySolver for the given name"""
        return _roadrunner.RoadRunner_makeSensitivitySolver(self, name)

    def getExistingIntegratorNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a list of the names of all existing integrators."""
        return _roadrunner.RoadRunner_getExistingIntegratorNames(self)

    def getExistingSteadyStateSolverNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a list of the names of all existing integrators."""
        return _roadrunner.RoadRunner_getExistingSteadyStateSolverNames(self)

    def getExistingSensitivitySolverNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a list of the names of all existing sensitivity solvers"""
        return _roadrunner.RoadRunner_getExistingSensitivitySolverNames(self)

    @staticmethod
    def getRegisteredIntegratorNames() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a std::vector of the names of all registered integrators"""
        return _roadrunner.RoadRunner_getRegisteredIntegratorNames()

    @staticmethod
    def getRegisteredSteadyStateSolverNames() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a std::vector of the names of all registered SteadyStateSolver names"""
        return _roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames()

    @staticmethod
    def getRegisteredSensitivitySolverNames() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Return a std::vector of the names of all registered sensitivity solvers"""
        return _roadrunner.RoadRunner_getRegisteredSensitivitySolverNames()

    def setIntegrator(self, name: "std::string const &") -> "void":
        r"""set the current Integrator to :param name;:"""
        return _roadrunner.RoadRunner_setIntegrator(self, name)

    def setSteadyStateSolver(self, name: "std::string const &") -> "void":
        r"""
        set the current SteadyStateSolver to :param name;:
        use getRegisteredSteadyStateSolverNames to
        get a list of available names
        """
        return _roadrunner.RoadRunner_setSteadyStateSolver(self, name)

    def setSensitivitySolver(self, name: "std::string const &") -> "void":
        r"""
        set the current SensitivitySolver to :param name;:
        use getRegisteredSensitivitySolverNames to
        get a list of available sensitivity solver names
        """
        return _roadrunner.RoadRunner_setSensitivitySolver(self, name)

    def integratorExists(self, name: "std::string const &") -> "bool":
        r"""
        returns true if integrator :type name: string
        :param name: exists.
        Use getRegisteredIntegratorNames to get a list of
        available integrator solver names.
        """
        return _roadrunner.RoadRunner_integratorExists(self, name)

    def steadyStateSolverExists(self, name: "std::string const &") -> "bool":
        r"""
        returns true if SteadyStateSolver :type name: string
        :param name: exists.
        """
        return _roadrunner.RoadRunner_steadyStateSolverExists(self, name)

    def sensitivitySolverExists(self, name: "std::string const &") -> "bool":
        r"""
        returns true if SensitivitySolver :type name: string
        :param name: exists.
        """
        return _roadrunner.RoadRunner_sensitivitySolverExists(self, name)

    @staticmethod
    def registerSolvers() -> "void":
        r"""Ensures all integrators and steady state solvers are registered"""
        return _roadrunner.RoadRunner_registerSolvers()

    def isModelLoaded(self) -> "bool":
        r"""

        RoadRunner.isModelLoaded()

        Return True if model was loaded; False otherwise

        """
        return _roadrunner.RoadRunner_isModelLoaded(self)

    def getModelName(self) -> "std::string":
        r"""returns the model name if a model is loaded, empty std::string otherwise."""
        return _roadrunner.RoadRunner_getModelName(self)

    def setModelName(self, name: "std::string const &") -> "void":
        r"""sets the model name if a model is loaded."""
        return _roadrunner.RoadRunner_setModelName(self, name)

    def getModelId(self) -> "std::string":
        r"""returns the model id if a model is loaded, empty std::string otherwise."""
        return _roadrunner.RoadRunner_getModelId(self)

    def setModelId(self, id: "std::string const &") -> "void":
        r"""sets the model id if a model is loaded."""
        return _roadrunner.RoadRunner_setModelId(self, id)

    def clearModel(self) -> "bool":
        r"""
        Clears the currently loaded model and all associated memory
        Deletes jitted code and libStruct data
        :rtype: boolean
        :return: True if memory was freed, false if no model was loaded
            in the first place
        """
        return _roadrunner.RoadRunner_clearModel(self)

    def oneStep(self, currentTime: "double", stepSize: "double", reset: "bool"=True) -> "double":
        r"""

        RoadRunner.oneStep(startTime, stepSize)

        Carry out a one step integration of the model. The method takes two arguments,
        the current time and the step size to us in the integration. The method returns
        the new time which will be currentTime + StepSize::

            newTime = rr.oneStep (10, 0.5)

        """
        return _roadrunner.RoadRunner_oneStep(self, currentTime, stepSize, reset)

    def internalOneStep(self, currentTime: "double", stepSize: "double", reset: "bool"=True) -> "double":
        r"""
        Carry out a single internal solver integration step.

        :param t0: starting time
        :param tf: final time
        :param options: override current options.
        """
        return _roadrunner.RoadRunner_internalOneStep(self, currentTime, stepSize, reset)

    def timeSeriesSensitivities(self, *args, **kwargs) -> "rr::Matrix3D< double,double >":
        r"""
        simulate a timeseries with sensitivities from start to step with num
        data points.
        Matrix3D indexed by time. Each element of the 3D matrix is a
        Matrix<double> with rows and columns parameters and model variables respectively.
        The parameter k determines the kth order derivative of the sensitivity information
        that will be returned
        :type start: float
        :param start: starting time for time series simulation
        :type stop: float
        :param stop: last time point for time series simulation
        :type num: int
        :param num: number of data points to simulate. Determines Z of Matrix3D.
        :type params: std::vector< std::string,std::allocator< std::string > >, optional
        :param params: vector of parameters that you want sensitivity for. When empty (default), compute
            sensitivities for all parameters vs all variables.
        :type species: std::vector< std::string,std::allocator< std::string > >, optional
        :param species: vector of species to include in the results
            Default is empty, in which case all species will be included.
            All species are selected during solving and slicing only occurs
            at the end.
        :type k: int, optional
        :param k: (default 0) return the kth other derivative of the sensitivity data.
        """
        return _roadrunner.RoadRunner_timeSeriesSensitivities(self, *args, **kwargs)

    def saveState(self, *args, **kwargs) -> "void":
        r"""
        similar to saveStateS but save data to file caled :type filename: string
        :param filename:.
        See also: RoadRunner::saveStateS
        See also: RoadRunner::loadState
        """
        return _roadrunner.RoadRunner_saveState(self, *args, **kwargs)

    def saveStateS(self, *args, **kwargs) -> "std::stringstream *":
        r"""
        save state as binary to a stringstream so it can be loaded again later.
        :rtype: std::stringstream
        :return: new reference to a stringstream - the caller is responsible for reclaiming memory
              Importantly, if the stream is read into a new RoadRunner instance via
              RoadRunner::loadStateS then the user no longer needs to handle the reference manually
              because RoadRunner::loadStateS does it after loading the state.
        :type opt: char, optional
        :param opt:, either 'b' (default) or 'r'. The latter is used for debugging.
        See also: RoadRunner::loadStateS
        See also: RoadRunner::saveState
        """
        return _roadrunner.RoadRunner_saveStateS(self, *args, **kwargs)

    def loadState(self, filename: "std::string const &") -> "void":
        r"""
        Loads a roadrunner instance saved by
        saveState with the 'b' option
        See also: RoadRunner::loadStateS
        See also: RoadRunner::saveState
        """
        return _roadrunner.RoadRunner_loadState(self, filename)

    def loadStateS(self, state: "std::stringstream *") -> "void":
        r"""
        load state from a :param stringstream:
            that was produced by RoadRunner::saveStateS.
        The stingstream pointer should be heap allocated
        and generated from RoadRunner::saveStateS. It is an error to
        use a stringstream that was generated in any other way. The memory
        associated with the stringstream is automatically cleaned up
        after loading the state.
        """
        return _roadrunner.RoadRunner_loadStateS(self, state)

    def getSimulationData(self) -> "ls::DoubleMatrix const *":
        r"""
        RoadRunner keeps a copy of the simulation data around until the
        next call to simulate. This matrix can be obtained here.
        """
        return _roadrunner.RoadRunner_getSimulationData(self)

    def setOptions(self, arg2: "RoadRunnerOptions") -> "void":
        return _roadrunner.RoadRunner_setOptions(self, arg2)

    def getSBML(self, level: "int"=0, version: "int"=0) -> "std::string":
        r"""

        RoadRunner.getSBML()

        Returns the original SBML model that was loaded into roadrunner.

        :rtype: str

        Selections
        ----------

        """
        return _roadrunner.RoadRunner_getSBML(self, level, version)

    def getCurrentSBML(self, level: "int"=0, version: "int"=0) -> "std::string":
        r"""

        RoadRunner.getCurrentSBML()

        Returns the current state of the model in the form of an SBML string.

        That is the SBML will reflect the current state of the model and not the
        original SBML that was loaded into RoadRunner.

        :rtype: str

        """
        return _roadrunner.RoadRunner_getCurrentSBML(self, level, version)

    def reset(self, *args) -> "void":
        r"""

        RoadRunner.reset()

        By default, reset all floating species concentrations and all variables changed by rate rules to their CURRENT init(X) values.

        It is possible to change the behavior of this function by providing a list of "or'ed" SelectionRecords.  For example, to reset only time and floating species, use:

        reset(SelectionRecord.TIME | SelectionRecord.FLOATING)

        The full list of recognized selection records are as follows.  These selection records are used by default:

        SelectionRecord.TIME:  Resets the time to zero.
        SelectionRecord.FLOATING:  Resets all floating species.
        SelectionRecord.RATE: Resets any variable or parameter that is changed by a rate rule (whether species, compartment, or parameter)

        The following selection records are added to the above when calling 'resetAll', and may be used separately or in concert with the above:

        SelectionRecord.BOUNDARY:  Resets the boundary species.
        SelectionRecord.COMPARTMENT:  Resets the compartments.
        SelectionRecord.GLOBAL_PARAMETER:  Resets the parameter objects.

        All of the above will use the current 'init(x)' values, and will re-calculate any initial assignments in the model based on the reset (or not reset) values they reference.  If one wishes to reset the model to its original state as defined in the SBML (resetting the 'init(x)' values as well), use:

        SelectionRecord.ALL:  Resets everything to as it was in the current SBML model.

        """
        return _roadrunner.RoadRunner_reset(self, *args)

    def resetSelectionLists(self) -> "void":
        r"""

        RoadRunner.resetSelectionLists()

        Resets time course and steady state selection lists to defaults



        Model Access
        ------------

        """
        return _roadrunner.RoadRunner_resetSelectionLists(self)

    def _getModel(self) -> "rr::ExecutableModel *":
        r"""

        RoadRunner.getModel()

        Function form of the RoadRunner.model property, identical to model.

        """
        return _roadrunner.RoadRunner__getModel(self)

    def _load(self, uriOrSBML: "std::string const &", options: "Dictionary"=None) -> "void":
        r"""

        RoadRunner.load(uriOrDocument)

        Loads an SBML document, given a string for file path, URI, or contents.

        This method also accepts HTTP URI for remote files, however this feature is currently limited
        to the Mac version, plan on enabling HTTP loading of SBML documents on Windows and Linux
        shortly.

        Some examples of loading files on Mac or Linux::

            >>> r.load("myfile.xml")                               # load a file from the current directory
            >>> r.load("/Users/Fred/myfile.xml")                   # absolute path
            >>> r.load("http://sbml.org/example_system.xml")       # remote file


        Or on Windows:

            >>> r.load("myfile.xml")                                  # load a file from the current directory
            >>> r.load("file://localhost/c:/Users/Fred/myfile.xml")   # using a URI

        One may also load the contents of a document::

            >>> myfile = open("myfile.xml, "r")
            >>> contents = file.read()
            >>> r.load(contents)

        In future version, we will also support loading directly from a libSBML Document object.

        :param uriOrDocument: A string which may be a local path, URI or contents of an SBML document.
        :type name: str

        """
        return _roadrunner.RoadRunner__load(self, uriOrSBML, options)

    def createSelection(self, str: "std::string const &") -> "rr::SelectionRecord":
        r"""

        RoadRunner.createSelection(sel)

        Create a new selection based on a selection string

        :rtype: roadrunner.SelectionRecord

        """
        return _roadrunner.RoadRunner_createSelection(self, str)

    def _setSelections(self, selections: "std::vector< std::string,std::allocator< std::string > > const &") -> "void":
        return _roadrunner.RoadRunner__setSelections(self, selections)

    def getSelectedValues(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        RoadRunner.getSelectedValues()

        returns the values selected with SimulateOptions for the current model time / timestep

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getSelectedValues(self)

    def _getIndependentFloatingSpeciesIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Author: JKM
        Gets the ids for all independent floating species
        Independent means (in this case) that the species is unique
        up to a conserved cycle, i.e. each conserved cycle counts for only
        one species. See Sauro, Systems Biology: Introduction to Pathway
        Modeling, 1st ed. pp. 60.
        """
        return _roadrunner.RoadRunner__getIndependentFloatingSpeciesIds(self)

    def _getDependentFloatingSpeciesIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Author: JKM
        Gets the ids for all dependent floating species
        See 'getIndependentFloatingSpeciesIds' for an explanation
        of independent vs. dependent.
        """
        return _roadrunner.RoadRunner__getDependentFloatingSpeciesIds(self)

    def getFloatingSpeciesInitialConcentrationIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets the ids for all initial floating species concentrations
        See 'getIndependentFloatingSpeciesIds' for an explanation
        of independent vs. dependent.
        """
        return _roadrunner.RoadRunner_getFloatingSpeciesInitialConcentrationIds(self)

    def getSupportedIdTypes(self) -> "int":
        r"""

        RoadRunner.getSupportedIdTypes()

        Returns a bitfield representing the element ID types which can be used with e.g.
        RoadRunner.getValue

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getSupportedIdTypes(self)

    def setValue(self, id: "std::string const &", value: "double") -> "void":
        r"""
        sets the value coresponding to the given selection std::string

        raises an exception in the selection std::string is invalid.
        """
        return _roadrunner.RoadRunner_setValue(self, id, value)

    def getFloatingSpeciesAmountsNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the floating species amounts as a named array
        """
        return _roadrunner.RoadRunner_getFloatingSpeciesAmountsNamedArray(self)

    def getFloatingSpeciesConcentrationsNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the floating species concentrations as a named array
        """
        return _roadrunner.RoadRunner_getFloatingSpeciesConcentrationsNamedArray(self)

    def getBoundarySpeciesAmountsNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the boundary species amounts as a named array
        """
        return _roadrunner.RoadRunner_getBoundarySpeciesAmountsNamedArray(self)

    def getBoundarySpeciesConcentrationsNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the boundary species concentrations as a named array
        """
        return _roadrunner.RoadRunner_getBoundarySpeciesConcentrationsNamedArray(self)

    def getRatesOfChange(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        RoadRunner::getRatesOfChange()

        Returns the rates of change of all floating species. The order of species is 
        given by the order of Ids returned by getFloatingSpeciesIds()

        :returns: a named array of floating species rates of change.
        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getRatesOfChange(self)

    def getRatesOfChangeNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the rate of change of the floating species as a named array
        """
        return _roadrunner.RoadRunner_getRatesOfChangeNamedArray(self)

    def getIndependentRatesOfChange(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        RoadRunner::getIndependentRatesOfChange()

        Returns the rates of change of all independent floating species. The order of species is 
        given by the order of Ids returned by getIndependentFloatingSpeciesIds()

        :returns: a named array of independent floating species rates of change.
        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getIndependentRatesOfChange(self)

    def getIndependentRatesOfChangeNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the rate of change of the independent floating species as a named array
        """
        return _roadrunner.RoadRunner_getIndependentRatesOfChangeNamedArray(self)

    def getDependentRatesOfChange(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        RoadRunner::getDependentRatesOfChange()

        Returns the rates of change of all dependent floating species. The order of species is 
        given by the order of Ids returned by getDependentFloatingSpeciesIds()

        :returns: a named array of dependent floating species rates of change.
        :rtype: numpy.ndarray



        Floating Species Initial Conditions
        -----------------------------------
        RoadRunner stores all initial conditions separately from the model state variables. This means that
        you can update the initial conditions at any time, and it does not affect the current state of the
        model. To reset the model, that is, reset it to its original state, or a new original state where
        what has changed the initial conditions use the :meth:`~ExecutableModel.reset()` method.

        The following methods allow access to the floating species initial condition values:

        """
        return _roadrunner.RoadRunner_getDependentRatesOfChange(self)

    def getDependentRatesOfChangeNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Author: KC
        Returns the rate of change of the dependent floating species as a named array
        """
        return _roadrunner.RoadRunner_getDependentRatesOfChangeNamedArray(self)

    def getFullJacobian(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getFullJacobian()

        Compute the full Jacobian at the current operating point.

        This is the Jacobian of ONLY the floating species.

        """
        return _roadrunner.RoadRunner_getFullJacobian(self)

    def getReducedJacobian(self, h: "double"=-1.0) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getReducedJacobian()

        Returns the *reduced* Jacobian for the independent species. This matrix will be non-singular
        for models that include moiety-conserved cycles.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getReducedJacobian(self, h)

    def getFullEigenValues(self) -> "std::vector< std::complex< double >,std::allocator< std::complex< double > > >":
        r"""

        RoadRunner.getFullEigenValues()


        Calculates the eigen values of the Full Jacobian as a real matrix, first column real part, second
        column imaginary part.

        Note, only valid for pure reaction kinetics models (no rate rules, no floating species rules and
        time invariant stoichiometry).

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getFullEigenValues(self)

    def getReducedEigenValues(self) -> "std::vector< std::complex< double >,std::allocator< std::complex< double > > >":
        r"""

        RoadRunner.getReducedEigenValues()


        Calculates the eigen values of the Reduced Jacobian as a real matrix, first column real part, second
        column imaginary part.

        Only valid if moiety conversion is enabled.

        Note, only valid for pure reaction kinetics models (no rate rules, no floating species rules and
        time invariant stoichiometry).

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getReducedEigenValues(self)

    def getFullEigenValuesNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Returns the eigenvalues of the full jacobian as a named array.

        This returns an N x 2 matrix where the first column is the
        real values and the second is the imaginary part.  The rows
        are labeled with the corresponding species ids, and the columns
        are labeled 'real' and 'imaginary'.
        """
        return _roadrunner.RoadRunner_getFullEigenValuesNamedArray(self)

    def getReducedEigenValuesNamedArray(self) -> "ls::DoubleMatrix":
        r"""
        Returns the eigenvalues of the reduced jacobian as a named array.

        This returns an N x 2 matrix where the first column is the
        real values and the second is the imaginary part.  The rows
        are labeled with the corresponding species ids, and the columns
        are labeled 'real' and 'imaginary'.
        """
        return _roadrunner.RoadRunner_getReducedEigenValuesNamedArray(self)

    def getLinkMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getLinkMatrix()

        Returns the full link matrix, L for the current model. The Link matrix is an m by r matrix where m
        is the number of floating species and r the rank of the stoichiometric matrix, N.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getLinkMatrix(self)

    def getNrMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getNrMatrix()

        Returns the reduced stoichiometry matrix, :math:`N_R`, which will have only r rows where r is the rank of
        the full stoichiometry matrix. The matrix will be reordered such that the rows of :math:`N_R` are independent.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getNrMatrix(self)

    def getKMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getKMatrix()

        Returns the K matrix, :math:`ker(N_R)`, (right nullspace of Nr)
        The K matrix has the structure, :math:`[I K0]'`

        :rtype: numpy.ndarray


        Analysis
        --------

        """
        return _roadrunner.RoadRunner_getKMatrix(self)

    def getReducedStoichiometryMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getReducedStoichiometryMatrix()

        get the reduced stochiometry matrix. If conservation conversion is enabled,
        this is the matrix that coresponds to the independent species.

        A synonym for getNrMatrix().

        """
        return _roadrunner.RoadRunner_getReducedStoichiometryMatrix(self)

    def getFullStoichiometryMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getFullStoichiometryMatrix()


        Get the stoichiometry matrix that coresponds to the full model, even it
        it was converted via conservation conversion.

        """
        return _roadrunner.RoadRunner_getFullStoichiometryMatrix(self)

    def getExtendedStoichiometryMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getExtendedStoichiometryMatrix()


        Returns the full stoichiometric matrix plus additional rows for boundary
        species and source/sink nodes. Use this if you want to apply detailed
        balance to the network as a whole.

        """
        return _roadrunner.RoadRunner_getExtendedStoichiometryMatrix(self)

    def getL0Matrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getL0Matrix()

        Returns the L0 matrix for the current model. The L0 matrix is an (m-r) by r matrix that expresses
        the dependent reaction rates in terms of the independent rates. m is the number of floating species
        and r is the rank of the stoichiometry matrix.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getL0Matrix(self)

    def getConservationMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getConservationMatrix()

        Returns a conservation matrix :math:`\\Gamma` which is a :math:`c \\times m` matrix
        where :math:`c` is the number of conservation laws and :math:`m` the number of species.

        """
        return _roadrunner.RoadRunner_getConservationMatrix(self)

    def getUnscaledConcentrationControlCoefficientMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getUnscaledConcentrationControlCoefficientMatrix()

        Returns the unscaled concentration control coefficient matrix.

        """
        return _roadrunner.RoadRunner_getUnscaledConcentrationControlCoefficientMatrix(self)

    def getScaledConcentrationControlCoefficientMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getScaledConcentrationControlCoefficientMatrix()

        Returns the m by n matrix of scaled concentration control coefficients where m is the number
        of floating species and n the number of reactions.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getScaledConcentrationControlCoefficientMatrix(self)

    def getUnscaledFluxControlCoefficientMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getUnscaledFluxControlCoefficientMatrix()

        Returns the unscaled flux control coefficient matrix.

        """
        return _roadrunner.RoadRunner_getUnscaledFluxControlCoefficientMatrix(self)

    def getScaledFluxControlCoefficientMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getScaledFluxControlCoefficientMatrix()

        Returns the n by n matrix of scaled flux control coefficients where n is the number of reactions.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getScaledFluxControlCoefficientMatrix(self)

    def getEigenValueIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        RoadRunner.getEigenValueIds()

        returns a list of selection symbols for the eigenvalues of the floating species. The eigen value
        selection symbol is ``eigen(XX)``, where ``XX`` is the floating species name.

        """
        return _roadrunner.RoadRunner_getEigenValueIds(self)

    def getUnscaledParameterElasticity(self, reactionName: "std::string const &", parameterName: "std::string const &") -> "double":
        r"""

        RoadRunner.getUnscaledParameterElasticity(reactionId, parameterId)

         Returns the unscaled elasticity for a named reaction with respect to a
         named parameter

        :param str reactionId: the SBML id of a reaction.
        :param str parameterId: the SBML id of a parameter.
        :rtype: double

        """
        return _roadrunner.RoadRunner_getUnscaledParameterElasticity(self, reactionName, parameterName)

    def getFrequencyResponse(self, startFrequency: "double", numberOfDecades: "int", numberOfPoints: "int", parameterName: "std::string const &", variableName: "std::string const &", useDB: "bool", useHz: "bool") -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getFrequencyResponse(startFrequency, numberOfDecades, numberOfPoints, parameterName, variableName, useDB, useHz)

        Compute the frequency response

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getFrequencyResponse(self, startFrequency, numberOfDecades, numberOfPoints, parameterName, variableName, useDB, useHz)

    def _setConservedMoietyAnalysis(self, value: "bool") -> "void":
        r"""This method turns on / off the computation and adherence to conservation laws."""
        return _roadrunner.RoadRunner__setConservedMoietyAnalysis(self, value)

    def _getConservedMoietyAnalysis(self) -> "bool":
        r"""is conservation analysis enabled. This is set"""
        return _roadrunner.RoadRunner__getConservedMoietyAnalysis(self)

    @staticmethod
    def getExtendedVersionInfo() -> "std::string":
        r"""

        RoadRunner.getExtendedVersionInfo()

        getVersion plus info about dependent libs versions.

        """
        return _roadrunner.RoadRunner_getExtendedVersionInfo()

    def getDiffStepSize(self) -> "double":
        r"""

        RoadRunner.getDiffStepSize()

        Returns the differential step size used in getCC and getuCC. Both functions
        use a 4th order finite difference method for calculating the derivative. The
        default value is 0.05.

          rr.getDiffStepSize ()
          0.05

        :rtype: double

        """
        return _roadrunner.RoadRunner_getDiffStepSize(self)

    def setDiffStepSize(self, val: "double") -> "void":
        r"""

        RoadRunner.setDiffStepSize(value)

        Sets the differential step size used in getCC and getuCC.

          rr.setDiffStepSize (0.05)

        """
        return _roadrunner.RoadRunner_setDiffStepSize(self, val)

    def getSteadyStateThreshold(self) -> "double":
        r"""
        Author: JKM
        Get the steady state threshold used in getCC
        In the MCA routines, RoadRunner will keep trying to
        converge to a steady state until this threshold is met
        """
        return _roadrunner.RoadRunner_getSteadyStateThreshold(self)

    def setSteadyStateThreshold(self, val: "double") -> "void":
        r"""
        Author: JKM
        Set the steady state threshold used in getCC
        In the MCA routines, RoadRunner will keep trying to
        converge to a steady state until this threshold is met
        """
        return _roadrunner.RoadRunner_setSteadyStateThreshold(self, val)

    def getuCC(self, variableName: "std::string const &", parameterName: "std::string const &") -> "double":
        r"""

        RoadRunner.getuCC(variableId, parameterId)

        Get unscaled control coefficient with respect to a global parameter.

        :param variableId: must be either a reaction or floating species.

        :param parameterId: must be either a global parameter, boundary species, or
                            conserved sum.

        """
        return _roadrunner.RoadRunner_getuCC(self, variableName, parameterName)

    def getCC(self, variableName: "std::string const &", parameterName: "std::string const &") -> "double":
        r"""

        RoadRunner.getCC(variable, parameter)

        Returns a scaled control coefficient with respect to a global parameter.

        For example::

          rr.getCC ('J1', 'Vmax')
          rr.getCC ('S1', 'Xo')
          rr.getCC ('S2', 'Km')

        The first returns a flux control coefficient with respect to flux J1. The second and third
        return concentration control coefficients with respect to species S1 and S2.

        :param variable: The id of a dependent variable of the coefficient, for example a
                         flux or species concentration.

        :param parameter: The id of the independent parameter, for example a kinetic constant
                          or boundary species

        :returns: the value of the control coefficient returned to the caller.

        :rtype: double

        """
        return _roadrunner.RoadRunner_getCC(self, variableName, parameterName)

    def getuEE(self, *args) -> "double":
        r"""

        RoadRunner.getuEE(reactionId, parameterId)

        Get unscaled elasticity coefficient with respect to a global parameter or species.

        """
        return _roadrunner.RoadRunner_getuEE(self, *args)

    def getEE(self, *args) -> "double":
        r"""

        RoadRunner.getEE(reactionId, parameterId, steadyState=True)

        Retrieve a single elasticity coefficient with respect to a global parameter.

        For example::

          x = rr.getEE ('J1', 'Vmax')

        :param str variable: The dependent variable of the coefficient, for example a flux or
                             species concentration.
        :param str parameter: The independent parameter, for example a kinetic constant or boundary
                              species
        :param Boolean steadyState: should the steady state value be computed.

        """
        return _roadrunner.RoadRunner_getEE(self, *args)

    def getUnscaledElasticityMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getUnscaledElasticityMatrix()

        Returns the unscaled species elasticity matrix at the current operating point.

        """
        return _roadrunner.RoadRunner_getUnscaledElasticityMatrix(self)

    def getScaledElasticityMatrix(self) -> "ls::DoubleMatrix":
        r"""

        RoadRunner.getScaledElasticityMatrix()

        Returns the scaled elasticity matrix at the current operating point.

        :rtype: numpy.ndarray


        Stochiometric Analysis
        ----------------------

        """
        return _roadrunner.RoadRunner_getScaledElasticityMatrix(self)

    def getScaledFloatingSpeciesElasticity(self, reactionName: "std::string const &", speciesName: "std::string const &") -> "double":
        r"""

        RoadRunner.getScaledFloatingSpeciesElasticity(reactionId, speciesId)

        Returns the scaled elasticity for a given reaction and given species.

        :param str reactionId: the SBML id of a reaction.
        :param str speciesId: the SBML id of a species.
        :rtype: double

        """
        return _roadrunner.RoadRunner_getScaledFloatingSpeciesElasticity(self, reactionName, speciesName)

    def getUnscaledSpeciesElasticity(self, reactionId: "int", speciesIndex: "int") -> "double":
        r"""

        RoadRunner.getUnscaledSpeciesElasticity(reactionIndx, speciesIndx)

        Get a single species elasticity value.


        :param int reactionIndx: index of reaction
        :param int speciesIndx: index of species.

        """
        return _roadrunner.RoadRunner_getUnscaledSpeciesElasticity(self, reactionId, speciesIndex)

    def _addSpeciesConcentration(self, *args, **kwargs) -> "void":
        r"""
        Add a species to the current model and set its concentration.
        :type sid: string
        :param sid:: the ID of the species to be added
        :type compartment: string
        :param compartment:: the compartment of the species to be added
        :type initConcentration: float
        :param initConcentration:: the initial concentration of the species to be added
        :type substanceUnits: string, optional
        :param substanceUnits:: the substance unit of the species to be added
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner__addSpeciesConcentration(self, *args, **kwargs)

    def _addSpeciesAmount(self, *args, **kwargs) -> "void":
        r"""
        Add a species to the current model.
        :type sid: string
        :param sid:: the ID of the species to be added
        :type compartment: string
        :param compartment:: the compartment of the species to be added
        :type initAmount: float, optional
        :param initAmount:: the initial amount of the species to be added
        :type substanceUnits: string, optional
        :param substanceUnits:: the substance unit of the species to be added
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner__addSpeciesAmount(self, *args, **kwargs)

    def removeSpecies(self, sid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_removeSpecies(self, sid, forceRegenerate)

    def setBoundary(self, sid: "std::string const &", boundaryCondition: "bool", forceRegenerate: "bool"=True) -> "void":
        r"""
        Set the boundary condition of an existing species.
        By default, the boundary condition for a species is false.
        :type sid: string
        :param sid:: the ID of the species
        :type boundaryCondition: boolean
        :param boundaryCondition:: boundary condition to be set
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_setBoundary(self, sid, boundaryCondition, forceRegenerate)

    def setHasOnlySubstanceUnits(self, sid: "std::string const &", hasOnlySubstanceUnits: "bool", forceRegenerate: "bool"=True) -> "void":
        r"""
        Set the hasOnlySubstanceUnits attribute for an existing species.
        :type sid: string
        :param sid:: the ID of a species
        :type hasOnlySubstanceUnits: boolean
        :param hasOnlySubstanceUnits:: the value of hasOnlySubstanceUnits attribute to be set
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_setHasOnlySubstanceUnits(self, sid, hasOnlySubstanceUnits, forceRegenerate)

    def getHasOnlySubstanceUnits(self, sid: "std::string const &") -> "bool":
        r"""
        Get the hasOnlySubstanceUnits attribute for an existing species.
        :type sid: string
        :param sid:: the ID of a species
        """
        return _roadrunner.RoadRunner_getHasOnlySubstanceUnits(self, sid)

    def setInitAmount(self, sid: "std::string const &", initAmount: "double", forceRegenerate: "bool"=True) -> "void":
        r"""
        Set initial amount for an existing species. Initial amount/concentration set before will be unset.
        :type sid: string
        :param sid:: the ID of a species
        :type initAmount: float
        :param initAmount:: the initial amount to be set
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_setInitAmount(self, sid, initAmount, forceRegenerate)

    def setInitConcentration(self, sid: "std::string const &", initConcentration: "double", forceRegenerate: "bool"=True) -> "void":
        r"""
        Set initial concentration for an existing species. Initial amount/concentration set before will be unset.
        :type sid: string
        :param sid:: the ID of a species
        :type initConcentration: float
        :param initConcentration:: the initial concentration to be set
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_setInitConcentration(self, sid, initConcentration, forceRegenerate)

    def setConstant(self, sid: "std::string const &", constant: "bool", forceRegenerate: "bool"=True) -> "void":
        r"""
        Set the constant attribute for an existing species/ parameter/ compartment
        By default, the constant attribute is false.
        :type sid: string
        :param sid:: the ID of a species/ parameter/ compartment
        :type constant: boolean
        :param constant:: the constant attribute to be set
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_setConstant(self, sid, constant, forceRegenerate)

    def addReaction(self, sbmlRep: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addReaction(self, sbmlRep, forceRegenerate)

    def _addReaction(self, rid: "std::string const &", reactants: "std::vector< std::string,std::allocator< std::string > >", products: "std::vector< std::string,std::allocator< std::string > >", kineticLaw: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner__addReaction(self, rid, reactants, products, kineticLaw, forceRegenerate)

    def removeReaction(self, rid: "std::string const &", deleteUnusedParameters: "bool"=False, forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove a reaction from the current model
        :type rid: string
        :param rid:: the ID of the reaction to be removed
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeReaction(self, rid, deleteUnusedParameters, forceRegenerate)

    def setReversible(self, rid: "std::string const &", reversible: "bool", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_setReversible(self, rid, reversible, forceRegenerate)

    def setKineticLaw(self, rid: "std::string const &", kineticLaw: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_setKineticLaw(self, rid, kineticLaw, forceRegenerate)

    def getKineticLaw(self, rid: "std::string const &") -> "std::string":
        r"""
        Get the kinetic law of an existing reaction in the current model.
        :type rid: string
        :param rid:: the ID of reaction to be modified
        """
        return _roadrunner.RoadRunner_getKineticLaw(self, rid)

    def _addParameter(self, pid: "std::string const &", value: "double", forceRegenerate: "bool"=True) -> "void":
        r"""
        Add a parameter to the current model
        :type pid: string
        :param pid:: the ID of the parameter to be added
        :type value: float
        :param value:: the value of the parameter to be added
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner__addParameter(self, pid, value, forceRegenerate)

    def removeParameter(self, pid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove a parameter from the current model
        :type pid: string
        :param pid:: the ID of the parameter to be removed
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeParameter(self, pid, forceRegenerate)

    def _addCompartment(self, cid: "std::string const &", initVolume: "double", forceRegenerate: "bool"=True) -> "void":
        r"""
        Add a compartment to the current model
        :type cid: string
        :param cid:: the ID of the compartment to be added
        :type initVolume: float
        :param initVolume:: the initial volume of the compartment to be added
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner__addCompartment(self, cid, initVolume, forceRegenerate)

    def removeCompartment(self, cid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove a compartment from the current model
        :type cid: string
        :param cid:: the ID of the compartment to be removed
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeCompartment(self, cid, forceRegenerate)

    def addAssignmentRule(self, vid: "std::string const &", formula: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addAssignmentRule(self, vid, formula, forceRegenerate)

    def addRateRule(self, vid: "std::string const &", formula: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addRateRule(self, vid, formula, forceRegenerate)

    def removeRules(self, vid: "std::string const &", useInitialValue: "bool"=False, forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove rules related to given variable from the current model
        :type vid: string
        :param vid:: ID of variable that rules assign formula to
        :type useInitialValue: boolean, optional
        :param useInitialValue:: a boolean value to indicate whether using initial value as
                                               current value when the assignment rule of a variable is removed
                                               otherwise, it will keep the value of assignment rule as current value
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeRules(self, vid, useInitialValue, forceRegenerate)

    def addInitialAssignment(self, vid: "std::string const &", formula: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addInitialAssignment(self, vid, formula, forceRegenerate)

    def removeInitialAssignment(self, vid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove initial assignment for a symbol from the current model
        :type vid: string
        :param vid:: ID of the symbol
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeInitialAssignment(self, vid, forceRegenerate)

    def addEvent(self, eid: "std::string const &", useValuesFromTriggerTime: "bool", trigger: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addEvent(self, eid, useValuesFromTriggerTime, trigger, forceRegenerate)

    def addTrigger(self, eid: "std::string const &", trigger: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addTrigger(self, eid, trigger, forceRegenerate)

    def setPersistent(self, eid: "std::string const &", persistent: "bool", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_setPersistent(self, eid, persistent, forceRegenerate)

    def setTriggerInitialValue(self, eid: "std::string const &", initValue: "bool", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_setTriggerInitialValue(self, eid, initValue, forceRegenerate)

    def addPriority(self, eid: "std::string const &", priority: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addPriority(self, eid, priority, forceRegenerate)

    def addDelay(self, eid: "std::string const &", delay: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addDelay(self, eid, delay, forceRegenerate)

    def addEventAssignment(self, eid: "std::string const &", vid: "std::string const &", formula: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        return _roadrunner.RoadRunner_addEventAssignment(self, eid, vid, formula, forceRegenerate)

    def removeEventAssignments(self, eid: "std::string const &", vid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove event assignments for given variable from an existing event
        :type eid: string
        :param eid:: the ID of the event
        :type eid: string
        :param eid:: the ID of the vairable of the event assignments
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeEventAssignments(self, eid, vid, forceRegenerate)

    def removeEvent(self, eid: "std::string const &", forceRegenerate: "bool"=True) -> "void":
        r"""
        Remove an event from the current model
        :type eid: string
        :param eid:: the ID of the event to be removed
        :type forceRegenerate: boolean, optional
        :param forceRegenerate:: a boolean value to indicate if the model is regenerated
            					       after this function call
            						   default value is true to regenerate model after each call
                                    of editing function
            						   to save time for editing for multiple times, one could
            					       set this flag to true only in the last call of editing
        """
        return _roadrunner.RoadRunner_removeEvent(self, eid, forceRegenerate)

    def validateCurrentSBML(self) -> "void":
        r"""Validate the current SBML"""
        return _roadrunner.RoadRunner_validateCurrentSBML(self)

    def mcaSteadyState(self) -> "double":
        return _roadrunner.RoadRunner_mcaSteadyState(self)

    def steadyState(self, dict: "Dictionary"=None) -> "double":
        r"""

        RoadRunner.steadyState()

        Attempt to evaluate the steady state for the model. The method returns
        a value that indicates how close the solution is to the steady state.
        The smaller the value the better. Values less than 1E-6 usually indicate a
        steady state has been found. If necessary the method can be called a
        second time to improve the solution.

        :returns: the sum of squares of the steady state solution.

        :rtype: double

        """
        return _roadrunner.RoadRunner_steadyState(self, dict)

    def steadyStateNamedArray(self, dict: "Dictionary"=None) -> "ls::DoubleMatrix":
        r"""Like 'steadyState' but returns a named array of the steady state values"""
        return _roadrunner.RoadRunner_steadyStateNamedArray(self, dict)

    def _setSteadyStateSelections(self, steadyStateSelections: "std::vector< std::string,std::allocator< std::string > > const &") -> "void":
        r"""
        parses the given list of strings and generates selections records
        which will be used for the steady state selections.
        """
        return _roadrunner.RoadRunner__setSteadyStateSelections(self, steadyStateSelections)

    def getSteadyStateValues(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        RoadRunner.getSteadyStateValues()

        Performs a steady state calculation (evolves the system to a steady
        state), then calculates and returns the set of values specified by
        the steady state selections. The variable steadyStateSelections is used
        to determine which values are returned.

             >>> rr.steadyStateSelections = ['S1']
             >>> rr.getSteadyStateValues()
             array([ 0.54314239])

        :returns: a numpy array corresponding to the values specified by steadyStateSelections

        :rtype: numpy.ndarray



        Metabolic control analysis
        --------------------------

        In the special case when an SBML model is a purely reaction kinetics model -- no rate rules, no
        assignment rules for chemical species, and time invariant stoichiometry, specialized analysis methods
        related to metabolic control analysis are applicable. These methods are described in this section.

        """
        return _roadrunner.RoadRunner_getSteadyStateValues(self)

    def getSteadyStateSelectionStrings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Returns a std::vector of the steady state selection strings"""
        return _roadrunner.RoadRunner_getSteadyStateSelectionStrings(self)

    def getSteadyStateValuesNamedArray(self) -> "ls::DoubleMatrix":
        r"""Like 'getSteadyStateValues' but returns a named array"""
        return _roadrunner.RoadRunner_getSteadyStateValuesNamedArray(self)

    def regenerateModel(self, forceRegenerate: "bool"=True, reset: "bool"=False) -> "void":
        r"""
        regenerate a model, this recompiles the internal runtime model.
        This would be used after a series of addSpecies, addReaction calls
        and the model is then ready to be compiled into executable form.
        """
        return _roadrunner.RoadRunner_regenerateModel(self, forceRegenerate, reset)

    def getAssignmentRuleIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Get the Ids of the elements assigned by assignment rules."""
        return _roadrunner.RoadRunner_getAssignmentRuleIds(self)

    def getRateRuleIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Get the Ids of the elements assigned by rate rules."""
        return _roadrunner.RoadRunner_getRateRuleIds(self)

    def getInitialAssignmentIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""Get the Ids of the elements with an initial assignment."""
        return _roadrunner.RoadRunner_getInitialAssignmentIds(self)

    def setGlobalParameterByName(self, param: "std::string const &", value: "double") -> "void":
        r"""
        Author: ciaran welsh
        set the parameter with id :type param: string
        :param param: to :type value: float
        :param value:
        """
        return _roadrunner.RoadRunner_setGlobalParameterByName(self, param, value)

    def getGlobalParameterByName(self, param: "std::string const &") -> "double":
        r"""
        Author: ciaran welsh
        get the :param value: of global parameter with id :type param: string
        :param param:
        """
        return _roadrunner.RoadRunner_getGlobalParameterByName(self, param)

    def getConservedMoietyValues(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Author: MTK, JKM
        Returns the sum of each conserved cycle
        """
        return _roadrunner.RoadRunner_getConservedMoietyValues(self)

    def getConservedMoietyIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _roadrunner.RoadRunner_getConservedMoietyIds(self)
    __simulateOptions = property(_roadrunner.RoadRunner___simulateOptions_get, _roadrunner.RoadRunner___simulateOptions_set, doc=r"""make some of these const so SWIG would not allow setting.""")
    options = property(_roadrunner.RoadRunner_options_get, _roadrunner.RoadRunner_options_set)

    def __repr__(self) -> "std::string":
        return _roadrunner.RoadRunner___repr__(self)

    def __str__(self) -> "std::string":
        return _roadrunner.RoadRunner___str__(self)

    def _simulate(self, opt: "SimulateOptions") -> "PyObject *":
        return _roadrunner.RoadRunner__simulate(self, opt)

    def _getValue(self, *args) -> "double":
        r"""

        RoadRunner.getValue(sel)

        Returns the value for a given selection.

        :param sel: a selection that is either a string or a SelectionRecord that was
                    obtained from createSelection
        :type sel: str or SelectionRecord

        """
        return _roadrunner.RoadRunner__getValue(self, *args)

    def __getitem__(self, id: "std::string const &") -> "double":
        return _roadrunner.RoadRunner___getitem__(self, id)

    def __setitem__(self, id: "std::string const &", value: "double") -> "void":
        return _roadrunner.RoadRunner___setitem__(self, id, value)

    def _getIds(self, types: "int") -> "PyObject *":
        return _roadrunner.RoadRunner__getIds(self, types)

    def _setSimulateOptionsTimes(self, opt: "SimulateOptions", list: "PyObject *") -> "void":
        return _roadrunner.RoadRunner__setSimulateOptionsTimes(self, opt, list)

    def _getSelections(self) -> "PyObject *":
        r"""returns the SelectionRecord vector python list of strings."""
        return _roadrunner.RoadRunner__getSelections(self)

    def _getSteadyStateSelections(self) -> "PyObject *":
        r"""returns the SelectionRecord vector python list of strings."""
        return _roadrunner.RoadRunner__getSteadyStateSelections(self)

    def __getattr__(self, name):
        if name != "this" and name in self._getIds(_roadrunner.SelectionRecord_ALL):
            return self[name]
        else:
            raise AttributeError(name)

    def getValue(self, *args):
        import re
        reg = re.compile(r'eigen\s*\(\s*(\w*)\s*\)\s*$')
        regarr = re.split(reg, args[0])

        if len(regarr) > 1:
           eig_r = _roadrunner.RoadRunner__getValue(self, 'eigenReal(' + str(regarr[1]) + ')')
           eig_i = _roadrunner.RoadRunner__getValue(self, 'eigenImag(' + str(regarr[1]) + ')')
           return complex(eig_r, eig_i)
        else:
            return _roadrunner.RoadRunner__getValue(self, *args)

    def setValues(self, keys, values):
        for key, val in zip(keys, values):
            _roadrunner.RoadRunner_setValue(self, key, val)

    def getModel(self):
        return self._getModel()

    def _setConservedMoietyAnalysisProxy(self, value):
        self._setConservedMoietyAnalysis(value)
        self._makeProperties()

    selections = property(_getSelections, _setSelections)
    timeCourseSelections = property(_getSelections, _setSelections)
    steadyStateSelections = property(_getSteadyStateSelections, _setSteadyStateSelections)
    conservedMoietyAnalysis = property(_getConservedMoietyAnalysis, _setConservedMoietyAnalysis)
    model = property(_getModel)
    integrator = property(getIntegrator, setIntegrator)

    # static list of properties added to the RoadRunner class object
    _properties = []

    def _makeProperties(self):
        """creates dynamic properties for model components, like floating species
        concentrations or amounts etc.
        """
    #global _properties

    # always clear the old properties
        for s in self._properties:
            if hasattr(RoadRunner, s):
                delattr(RoadRunner, s)

    # properties now empty
        RoadRunner._properties = []

    # check if we should make new properties
        if Config.getValue(Config.ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES):
            return

    # can't make properties without a model.
        if self.getModel() is None:
            return

        def makeProperty(name, sel):
            prop = property(
                    lambda self: self.getModel().__getitem__(sel),
                    lambda self, val: self.getModel().__setitem__(sel, val)
            )
            setattr(RoadRunner, name, prop)
            RoadRunner._properties.append(name)

        model = self.getModel()
        for s in model.getFloatingSpeciesIds():
            makeProperty(s, "[" + s + "]")  # concentrations for backwards compatibility
            makeProperty(s + "_conc", "[" + s + "]")  # concentrations
            makeProperty(s + "_amt", s)     # amounts


        for s in model.getBoundarySpeciesIds():
            makeProperty(s, "[" + s + "]")  # concentrations for backwards compatibility
            makeProperty(s + "_conc", "[" + s + "]")  # concentrations
            makeProperty(s + "_amt", s)     # amounts


        for s in model.getGlobalParameterIds() + model.getCompartmentIds() + model.getReactionIds() + model.getConservedMoietyIds():
            makeProperty(s, s)

    def __getstate__(self):
        return self.saveStateS()

    def __setstate__(self, state):
        rr = RoadRunner()
        rr.loadStateS(state)
        self.__dict__ = rr.__dict__

    # Set up the python dyanic properties for model access,
    # save the original init method
    _swig_init = __init__

    def _new_init(self, *args):

    # if called with https, use Python for transport
        if len(args) >= 1:
            p = args[0]
            if hasattr(p,'startswith') and p.startswith('https://'):
                try:
    # Python3
                    from urllib.request import urlopen
                except ImportError:
    # Python2
                    from urllib2 import urlopen
                sbml = urlopen(p).read()
                try:
                    sbml = str(sbml.decode())
                except:
                    pass
                RoadRunner._swig_init(self, sbml)
                RoadRunner._makeProperties(self)
                return

    # Otherwise, use regular init
        RoadRunner._swig_init(self, *args)
        RoadRunner._makeProperties(self)

    # set the ctor to use the new init
    __init__ = _new_init

    def load(self, *args):
        self._load(*args)
        RoadRunner._makeProperties(self)

    def keys(self, types=_roadrunner.SelectionRecord_ALL):
        return self.getIds(types)

    def getIds(self, types=_roadrunner.SelectionRecord_ALL):
        """
        Return a list of selection ids that this object can select on.

        The optional argument 'types' may be a selection record which by default
        is roadrunner.SelectionRecord.ALL

        :rtype: list
        """

        return self._getIds(types)

    def values(self, types=_roadrunner.SelectionRecord_ALL):
        return [self.getValue(k) for k in self.keys(types)]

    def items(self, types=_roadrunner.SelectionRecord_ALL):
        return [(k, self.getValue(k)) for k in self.keys(types)]

    def __len__(self):
        return len(self.keys())

    def iteritems(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over (key, value) pairs
        """
        return self.items(types).__iter__()

    def iterkeys(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's keys
        """
        return self.keys(types).__iter__()

    def itervalues(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's values
        """
        return self.values(types).__iter__()

    def simulate(self, start=None, end=None, points=None, selections=None, output_file=None, steps=None, times=None):
        '''
        Simulate and optionally plot current SBML model. This is the one stop shopping method
        for simulation and plotting.

        simulate accepts up to five positional arguments.

        The first five (optional) arguments are treated as:

            1: Start Time, if this is a number.

            2: End Time, if this is a number.

            3: Number of points, if this is a number.

            4: List of Selections. A list of variables to include in the output, e.g. ``['time','A']`` for a model with species ``A``. More below.

            5: output file path. The file to which simulation results will be written. If this is specified and
            nonempty, simulation output will be written to output_file every Config::K_ROWS_PER_WRITE generated.
            Note that simulate() will not return the result matrix if it is writing to output_file.
            It will also not keep any simulation data, so in that case one should not call ``r.plot()``
            without arguments. This should be specified when one cannot, or does not want to, keep the
            entire result matrix in memory.


        All five of the positional arguments are optional. If any of the positional arguments are
        a list of string instead of a number, then they are interpreted as a list of selections.

        There are a number of ways to call simulate.

        1: With no arguments. In this case, the current set of options from the previous
          ``simulate`` call will be used. If this is the first time ``simulate`` is called,
          then a default set of values is used. The default set of values are (start = 0, end = 5, points = 51).

        2: With up to five positions arguments, described above.

        Finally, you can pass keyword arguments.  The above options can all be set by keyword (start, end, points, selections, and output_file), or as an alternative you can use 'steps' instead of 'points', or 'times' instead of start/end/points:

        steps (Optional) Number of steps at which the output is sampled where the samples are evenly spaced. Steps = points-1. Steps and points may not both be specified.

        times (Optional): Explicit time output vector.  A list of time points at which to produce output.  For example, passing in [0, 1, 5, 10] will produce output at those time points specifically, which would not be possible with evenly-spaced timepoints using start/end/points.  Will override the start/end/points values if used.

        '''

    # fix issue #401 - this will check if a list was positioned at 3rd position. This allows users to
    # omit positional arguement points. This is un-Pythonic, but implemented for the sake of novice users.
        if type(points) == list:
            selections = points
            points = None

    # check for errors
        import collections
        import sys
        import warnings
        if selections is not None:
    # check that selections is a sequence
            if not isinstance(selections, collections.Sequence):
                raise ValueError('Expected a sequence type for selections')

    # check that selections contains only strings
            for x in selections:
                if sys.version_info >= (3,0):
                    if not isinstance(x, str):
                        raise ValueError('Expected selections to be a sequence of strings')
                else:
                    if not isinstance(x, basestring):
                        raise ValueError('Expected selections to be a sequence of strings')

        if points is not None and steps is not None:
            raise ValueError('Cannot specify both points and steps in simulate call')

        if points is not None:
            if points < 2:
                raise ValueError('Number of points cannot be less than 2')

        if steps is not None:
            if steps < 1:
                raise ValueError('Number of steps cannot be less than 1')

        has_output_file = False
        if output_file is not None:
            if not isinstance(output_file, str):
                raise ValueError('Output file path must be a string')

            has_output_file = bool(output_file)  # if not empty string


    # end error checking

        o = self.__simulateOptions
        originalSteps = o.steps
        originalVSS = True;
        o.reset()

        if self.getIntegrator().hasValue('variable_step_size'):
            originalVSS = self.getIntegrator().getValue('variable_step_size')
            if end is not None and (points is not None or steps is not None):
               self.getIntegrator().setValue('variable_step_size', False)
            else:
               if originalVSS == True:
                    o.steps = 0

        if start is not None:
            o.start = start

        if end is not None:
            o.end = end

        if points is not None:
            o.steps = points - 1
        elif steps is not None:
            o.steps = steps


        if selections is not None:
            self.timeCourseSelections = selections

        if times is not None:
            if start is not None or end is not None or points is not None or steps is not None:
                raise ValueError("Cannot call 'simulate' with the 'times' argument plus any of 'start', 'end', 'points' or 'steps' defined.")
            self._setSimulateOptionsTimes(o, list(times))

        if has_output_file:
            o.output_file = output_file
        else:
            o.output_file = ""

        result = self._simulate(o)

    #Check to make sure we made it to the 'end'.
        selections_lower = [x.lower() for x in self.timeCourseSelections]
        if end is not None and "time" in selections_lower:
            lastresult_time = result[len(result)-1][selections_lower.index("time")]
            if end - lastresult_time > end/10000:
                warnings.warn("Simulation requested end time point (" + str(end) + ") not reached, because the maximum number of steps reached.  Possible solutions include:\n  * Setting an explicit number of points (i.e. r.simulate(" + str(start) + ", " + str(end) + ", 1001)\n  * Setting r.integrator.variable_step_size to 'False'\n  * Setting r.integrator.max_output_rows to a larger number ")

    #Reset any integrator variables we might have changed
        o.steps = originalSteps
        if self.getIntegrator().hasValue('variable_step_size'):
            self.getIntegrator().setValue('variable_step_size', originalVSS)

        if has_output_file:
    # result should be empty here.
            return 'Your results have been written to "{}".'.format(output_file)\
                + 'To obtain the results directly, pass None or "" to the output_file keyword argument'

        return result

    def __simulateOld(self, *args, **kwargs):
        """
        DEPRECATED!!!!!!!!!!!!!!!!
        WILL BE REMOVED

        Simulate the current SBML model.

        simulate accepts a up to four positional arguments. The first four (optional) arguments are treated as:

        1: start (the simulation starting time)

        2: end (the simulation end time)

        3: steps (the number of output points)

        4: List of Selections.

        All four of the positional arguments are optional. If any of the positional arguments are
        supplied as a list of strings, then they are interpreted as a list of selections.


        There is only one correct way to call simulate. If one positional argument is specified,
        it is the start time. If two are specified, they are the start and end time.
        The third argument is the number of output points!
        The fourth argument, if it is supplied, must be a list of strings that correspond to
        proper timecourse selections as in timeCourseSelections.
        The fifth argument, if supplied via keyword, is the number of intervals, not the
        number of points. Specifying intervals and points is an error.

        Do NOT pass a `SimulateOptions` object to this function. SimulateOptions is DEPRECATED.

        Keyword arguments:

        integrator
            DEPRECATED: use setIntegrator method

        sel or selections
            A list of strings specifying what values to display in the output.

        plot
            DEPRECATED: use plot method.

        end
            The simulation end time. Note, setting the end time automatically sets
            the duration accordingly and visa versa.

        resetModel
            DEPRECATED

        reset
            DEPRECATED: use reset method.

        start
            The start time of the simulation time-series data. Often this is 0,
            but not necessarily.

        steps
            The number of steps at which the output is sampled. The samples are evenly spaced.
            When a simulation system calculates the data points to record, it will typically
            divide the duration by the number of time steps. Thus, for N steps, the output
            will have N+1 data rows.

        stiff
            DEPRECATED: use solver wrappers (this setting only available for some solvers).

        seed
            DEPRECATED: use solver wrappers (this setting only available for some solvers).


        :returns: a numpy array with each selected output time series being a
         column vector, and the 0'th column is the simulation time (if time is selected as an
         output).
        :rtype: numpy.ndarray
        """

        doPlot = False
        showPlot = True

    # cleanup tasks
        post_tasks = []

    # user specified number of steps via 3rd arg or steps=xxx
        haveSteps = False

    # variableStep = True was specified in args
        haveVariableStep = False
        o = self.__simulateOptions

        def steps_restore(v):
            def f():
                o.steps = v
            return f
        post_tasks.append(steps_restore(o.steps))

        o.steps = 50
        if self.getIntegrator().hasValue('variable_step_size'):
            if self.getIntegrator().getValue('variable_step_size') == True:
                o.steps = 0
        stepsSpecified = False

    # did the options originally have a seed, if so, don't delete it when we're done
        hadSeed = "seed" in o

    # check if we have just a sim options
        if len(args) >= 1:
            if type(args[0]) == type(self.__simulateOptions):
                o = args[0]
            elif type(args[0]) == list:
    # its a selection list
                self.timeCourseSelections = args[0]
            elif isinstance(args[0], (int, float)):
    # treat it as a number
                o.start = args[0]
            else:
                raise ValueError("argument 1 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[0])))

    # second arg is treated as sim end time
        if len(args) >= 2:
            if type(args[1]) == list:
    # its a selection list
                self.timeCourseSelections = args[1]
            elif isinstance(args[1], (int, float)):
    # treat it as a number
                o.end = args[1]
            else:
                raise ValueError("argument 2 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[1])))


    # third arg is treated as number of points
        if len(args) >= 3:
            if type(args[2]) == list:
    # its a selection list
                self.timeCourseSelections = args[2]
            elif isinstance(args[2], (int, float)):
    # treat it as a number
                o.steps = args[2]-1
                stepsSpecified = True
                if o.steps < 1:
                  raise RuntimeError('Number of points must be 2 or more')
                haveSteps = True
            else:
                raise ValueError("argument 3 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[2])))

    # forth arg may be a list (currently)
        if len(args) >= 4:
            if type(args[3]) == list:
    # its a selection list
                self.timeCourseSelections = args[3]
            else:
                raise ValueError("argument 4 (if given) must be a list of timeCourseSelections "
                                 ", recieved: {0}".format(str(args[3])))


    # go through the list of keyword args
        for k,v in kwargs.items():

    # changing integrators.
            if k == "integrator":
                if type(v) == str:
    # this automatically sets the variable / fixed time step
    # according to integrator type, raises exception if invalid
    # integrator string.
                    self.setIntegrator(v)
                else:
                    raise Exception("{0} is invalid argument for integrator, integrator name must be a string.".format(v))
                continue

    # specifying timeCourseSelections:
            if k == "timeCourseSelections" or k == "sel":
                self.timeCourseSelections = v
                continue

            if k == "steps":
                o.steps = v
                stepsSpecified = True
                continue

            if k == "start":
                o.start = v
                continue

            if k == "end":
                o.end = v
                continue

    # reset model, also accept 'reset'
            if k == "reset" or k == "resetModel":
                o.resetModel = v
                continue

    # check if variableStep was explicitly specified, this overrides the steps
    # positional arg
            if k == "variableStep":
                raise KeyError('Do NOT pass variableStep to simulate. Use integrator wrappers: r.getIntegrator().setValue("variable_step_size", True)')
                haveVariableStep = True
                self.getIntegrator().setValue('variable_step_size', v)
                if not stepsSpecified:
                    o.steps = 0
                continue

            if k == "plot":
                raise RuntimeError('plot argument is deprecated, use plot method')
                continue

            if k == "show":
                showPlot = v
                continue

            if k == "stiff" and self.getIntegrator().hasValue('stiff'):
                raise KeyError('Do NOT pass stiff to simulate. Use the integrator wrappers: r.getIntegrator().setValue("stiff", True)')
                def stiff_restore(v):
                    def f():
                        self.getIntegrator().setValue('stiff', v)
                    return f
                self.getIntegrator().setValue('stiff', kwargs[k])
                post_tasks.append(stiff_restore(self.getIntegrator().getValue('stiff')))
                continue

    # if its not one of these, just set the item on the dict, and
    # if the inegrator cares about it, it will use it.
    # if its one of these, set it.
            raise KeyError('No such argument: {}'.format(k))



    # if we are doing a stochastic sim,
    # explicit options of variableStep trumps everything,
    # if not explicit, variableStep is if number of steps was specified,
    # if no steps, varStep = true, false otherwise.
        if self.getIntegrator().getIntegrationMethod() == \
            Integrator.Stochastic and not haveVariableStep:
            self.getIntegrator().setValue('variable_step_size', not haveSteps)

    # the options are set up, now actually run the simuation...
        result = self._simulate(o)

        if not hadSeed:
            del o["seed"]

        if doPlot:
            self.plot(result=None, loc='upper left', show=showPlot)

    # revert any settings we changed
        for x in post_tasks:
            x()

        return result

    def resetToOrigin(self):
        """ Reset model to state when first loaded.

        This resets the model back to the state when it was FIRST loaded,
        this includes all init() and parameters such as k1 etc.

        identical to:
            r.reset(SelectionRecord.ALL)
        """
        self.reset(SelectionRecord.ALL)

    def resetAll(self):
        """ Reset all model variables to CURRENT init(X) values.

        This resets all variables and parameters in the model (S1, S2, k1, etc.) to the CURRENT init(X) values.
        """
        self.reset(SelectionRecord.TIME |
                   SelectionRecord.RATE |
                   SelectionRecord.FLOATING |
                   SelectionRecord.BOUNDARY |
                   SelectionRecord.COMPARTMENT |
                   SelectionRecord.GLOBAL_PARAMETER)

    def resetParameter(self):
        """ Reset parameters to CURRENT init(X) values.

        This resets all parameters to the CURRENT init(X) values.
        """
        self.reset(SelectionRecord.GLOBAL_PARAMETER)

    def getAvailableIntegrators(self):
        """
        get a list of available integrator names.
        """
        return self.getExistingIntegratorNames()


    def plot(self, result=None, loc='upper left', show=True):
        """
        RoadRunner.plot([show])

        Plot the previously run simulation result using Matplotlib.

        This takes the contents of the simulation result and builds a
        legend from the selection list.


        If the optional prameter 'show' [default is True] is given, the pylab
        show() method is called.
        """

        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')

        result = self.getSimulationData()

        if result is None:
            raise Exception("no simulation result")

        rval = []

    # check if standard numpy array
        if result.dtype.names is None:

            timeCourseSelections = self.timeCourseSelections

            if len(result.shape) != 2 or result.shape[1] != len(timeCourseSelections):
                raise Exception("simulation result columns not equal to number of selections, likely a simulation has not been run")

            times = result[:,0]

            for i in range(1, len(timeCourseSelections)):
                series = result[:,i]
                name = timeCourseSelections[i]
                rval.append(p.plot(times, series, label=str(name), linewidth=2))

    # result is structured array
        else:
            if len(result.dtype.names) < 1:
                raise Exception('no columns to plot')

            time = result.dtype.names[0]

            for name in result.dtype.names[1:]:
                rval.append(p.plot(result[time], result[name], label=name, linewidth=2))

        if show:
            p.show()

        return rval

    def plotLegend(self):
        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')
        p.legend()

    def showPlot(self):
        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')
        p.show()

    def getIndependentFloatingSpeciesIds(self):
        return list(self._getIndependentFloatingSpeciesIds())

    def getDependentFloatingSpeciesIds(self):
        return list(self._getDependentFloatingSpeciesIds())

    def getReactionRates(self):
        return self.getModel().getReactionRates()

    integrator = property(getIntegrator, setIntegrator)
    #if _newclass:
    #integrator = property(getIntegrator, setIntegrator)

    def setIntegratorSetting(self, integratorName, settingName, value):
        import sys
        if sys.version_info >= (3,0):
            if not isinstance(integratorName, str):
                raise ValueError('Expected integratorName to be a string')
            if not isinstance(settingName, str):
                raise ValueError('Expected settingName to be a string')
        else:
            if not isinstance(integratorName, basestring):
                raise ValueError('Expected integratorName to be a string')
            if not isinstance(settingName, basestring):
                raise ValueError('Expected settingName to be a string')

    # store original integrator and switch back to it afterwards
        origIntegrator = self.getIntegrator().getName()

        self.setIntegrator(integratorName)
        self.getIntegrator().setValue(settingName, value)
        self.setIntegrator(origIntegrator)

    @property
    def steadyStateSolver(self):
        '''The current steady state solver'''
        return self.getSteadyStateSolver()

    @steadyStateSolver.setter
    def steadyStateSolver(self, v):
        self.setSteadyStateSolver(v)

    def addParameter(self, *args):
        self._addParameter(*args)
        self._makeProperties()

    def addReaction(self, *args):
        self._addReaction(*args)
        self._makeProperties()

    def addSpecies(self, sid, compartment, initAmount = 0.0, initConcentration = 0.0, hasOnlySubstanceUnits=False, boundaryCondition=False, substanceUnits = "", forceRegenerate = True):
        if initConcentration==0.0:
            self._addSpeciesAmount(sid, compartment, initAmount, hasOnlySubstanceUnits, boundaryCondition, substanceUnits, forceRegenerate)
        elif initAmount==0.0:
            self._addSpeciesConcentration(sid, compartment, initConcentration, hasOnlySubstanceUnits, boundaryCondition, substanceUnits, forceRegenerate)
        else:
            raise AttributeError("When calling 'addSpecies' you may only define initAmount or initConcentration, not both.")

        self._makeProperties()

    def addSpeciesAmount(self, sid, compartment, initAmount = 0.0, hasOnlySubstanceUnits=False, boundaryCondition=False, substanceUnits = "", forceRegenerate = True):
        self._addSpeciesAmount(sid, compartment, initAmount, hasOnlySubstanceUnits, boundaryCondition, substanceUnits, forceRegenerate)
        self._makeProperties()

    def addSpeciesConcentration(self, sid, compartment, initConcentration = 0.0, hasOnlySubstanceUnits=False, boundaryCondition=False, substanceUnits = "", forceRegenerate = True):
        self._addSpeciesConcentration(sid, compartment, initConcentration, hasOnlySubstanceUnits, boundaryCondition, substanceUnits, forceRegenerate)
        self._makeProperties()

    def addCompartment(self, *args):
        self._addCompartment(*args)
        self._makeProperties()

    def _diffstep_getter(self):
        '''Differential step size used in MCA'''
        return self.getDiffStepSize()

    def _diffstep_stter(self, v):
        self.setDiffStepSize(v)

    diffstep = property(_diffstep_getter, _diffstep_stter)

    def _steadyStateThresh_getter(self):
        '''Steady state threshold used in MCA'''
        return self.getSteadyStateThreshold()

    def _steadyStateThresh_setter(self, v):
        self.setSteadyStateThreshold(v)

    steadyStateThresh = property(_steadyStateThresh_getter, _steadyStateThresh_setter)


# Register RoadRunner in _roadrunner:
_roadrunner.RoadRunner_swigregister(RoadRunner)

def RoadRunner_getParamPromotedSBML(sArg: "std::string const &") -> "std::string":
    r"""

    RoadRunner.getParamPromotedSBML(*args)

    Takes an SBML document or path to an SBML document and changes all of the local parameters
    to be global parameters.

    :param str SBML: the contents or path to an SBML document
    :rtype: str

    """
    return _roadrunner.RoadRunner_getParamPromotedSBML(sArg)

def RoadRunner_getRegisteredIntegratorNames() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""Return a std::vector of the names of all registered integrators"""
    return _roadrunner.RoadRunner_getRegisteredIntegratorNames()

def RoadRunner_getRegisteredSteadyStateSolverNames() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""Return a std::vector of the names of all registered SteadyStateSolver names"""
    return _roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames()

def RoadRunner_getRegisteredSensitivitySolverNames() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""Return a std::vector of the names of all registered sensitivity solvers"""
    return _roadrunner.RoadRunner_getRegisteredSensitivitySolverNames()

def RoadRunner_registerSolvers() -> "void":
    r"""Ensures all integrators and steady state solvers are registered"""
    return _roadrunner.RoadRunner_registerSolvers()

def RoadRunner_getExtendedVersionInfo() -> "std::string":
    r"""

    RoadRunner.getExtendedVersionInfo()

    getVersion plus info about dependent libs versions.

    """
    return _roadrunner.RoadRunner_getExtendedVersionInfo()

class SelectionRecord(object):
    r"""

    SelectionRecord.__init__(str)
    Create a new selection record. This constructor really should not be called,
    SelectionRecords should be created by the RoadRunner.createSelection

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    TIME = _roadrunner.SelectionRecord_TIME
    r"""



    """
    CONCENTRATION = _roadrunner.SelectionRecord_CONCENTRATION
    r"""



    """
    AMOUNT = _roadrunner.SelectionRecord_AMOUNT
    r"""


    species must have either a CONCENTRATION or AMOUNT
    modifer to distinguish it.

    """
    RATE = _roadrunner.SelectionRecord_RATE
    r"""



    """
    BOUNDARY = _roadrunner.SelectionRecord_BOUNDARY
    r"""



    """
    FLOATING = _roadrunner.SelectionRecord_FLOATING
    r"""



    """
    _COMPARTMENT = _roadrunner.SelectionRecord__COMPARTMENT
    r"""
    SelectionType for comparments. Compartments and parameters can be either current
    or initial values. These values with and underscore, '_'
    are intended to be used with either an CURRENT or
    INITIAL value modifier.
    """
    _GLOBAL_PARAMETER = _roadrunner.SelectionRecord__GLOBAL_PARAMETER
    r"""
    SelectionType for global parameters. Compartments and parameters can be either current
    or initial values. These values with and underscore, '_'
    are intended to be used with either an CURRENT or
    INITIAL value modifier.
    """
    REACTION = _roadrunner.SelectionRecord_REACTION
    r"""



    """
    INITIAL = _roadrunner.SelectionRecord_INITIAL
    r"""



    """
    CURRENT = _roadrunner.SelectionRecord_CURRENT
    r"""



    """
    UNSCALED = _roadrunner.SelectionRecord_UNSCALED
    r"""



    """
    ELASTICITY = _roadrunner.SelectionRecord_ELASTICITY
    r"""



    """
    CONTROL = _roadrunner.SelectionRecord_CONTROL
    r"""



    """
    EIGENVALUE_REAL = _roadrunner.SelectionRecord_EIGENVALUE_REAL
    r"""SelectionType for eigenvalues. Eigenvalue without complex is real part of eigenvalue."""
    ELEMENT = _roadrunner.SelectionRecord_ELEMENT
    r"""



    """
    STOICHIOMETRY = _roadrunner.SelectionRecord_STOICHIOMETRY
    r"""



    """
    UNKNOWN = _roadrunner.SelectionRecord_UNKNOWN
    r"""



    """
    DEPENDENT = _roadrunner.SelectionRecord_DEPENDENT
    r"""



    """
    INDEPENDENT = _roadrunner.SelectionRecord_INDEPENDENT
    r"""



    """
    CONSERVED_MOIETY = _roadrunner.SelectionRecord_CONSERVED_MOIETY
    r"""SelectionType for conserved moieties."""
    STATE_VECTOR = _roadrunner.SelectionRecord_STATE_VECTOR
    r"""SelectionType for state vectors."""
    EVENT = _roadrunner.SelectionRecord_EVENT
    r"""SelectionType for events."""
    EIGENVALUE_IMAG = _roadrunner.SelectionRecord_EIGENVALUE_IMAG
    r"""
    SelectionType for complex values. The complex bit, off to get real values, on to get imaginary parts.

    Only used with EIGENVALUE currently.
    """
    ALL = _roadrunner.SelectionRecord_ALL
    r"""



    """
    EIGENVALUE_COMPLEX = _roadrunner.SelectionRecord_EIGENVALUE_COMPLEX
    r"""SelectionType for complex eigenvalues."""
    UNKNOWN_CONCENTRATION = _roadrunner.SelectionRecord_UNKNOWN_CONCENTRATION
    r"""



    """
    COMPARTMENT = _roadrunner.SelectionRecord_COMPARTMENT
    r"""



    """
    GLOBAL_PARAMETER = _roadrunner.SelectionRecord_GLOBAL_PARAMETER
    r"""



    """
    FLOATING_AMOUNT = _roadrunner.SelectionRecord_FLOATING_AMOUNT
    r"""



    """
    INDEPENDENT_FLOATING_AMOUNT = _roadrunner.SelectionRecord_INDEPENDENT_FLOATING_AMOUNT
    r"""SelectionType for independent floating species amounts."""
    DEPENDENT_FLOATING_AMOUNT = _roadrunner.SelectionRecord_DEPENDENT_FLOATING_AMOUNT
    r"""SelectionType for dependent floating species amounts. (Unused)"""
    FLOATING_CONCENTRATION = _roadrunner.SelectionRecord_FLOATING_CONCENTRATION
    r"""



    """
    FLOATING_AMOUNT_RATE = _roadrunner.SelectionRecord_FLOATING_AMOUNT_RATE
    r"""



    """
    FLOATING_CONCENTRATION_RATE = _roadrunner.SelectionRecord_FLOATING_CONCENTRATION_RATE
    r"""



    """
    BOUNDARY_AMOUNT = _roadrunner.SelectionRecord_BOUNDARY_AMOUNT
    r"""



    """
    INDEPENDENT_BOUNDARY_AMOUNT = _roadrunner.SelectionRecord_INDEPENDENT_BOUNDARY_AMOUNT
    r"""SelectionType for independent boundary species amounts."""
    DEPENDENT_BOUNDARY_AMOUNT = _roadrunner.SelectionRecord_DEPENDENT_BOUNDARY_AMOUNT
    r"""SelectionType for dependent boundary species amounts. (Unused)"""
    BOUNDARY_CONCENTRATION = _roadrunner.SelectionRecord_BOUNDARY_CONCENTRATION
    r"""



    """
    BOUNDARY_AMOUNT_RATE = _roadrunner.SelectionRecord_BOUNDARY_AMOUNT_RATE
    r"""
    SelectionType for boundary species amount rates (value, not reaction rates),
    these are always current.
    """
    BOUNDARY_CONCENTRATION_RATE = _roadrunner.SelectionRecord_BOUNDARY_CONCENTRATION_RATE
    r"""
    SelectionType for boundary species concentration rates (value, not reaction rates),
    these are always current. (Unused)
    """
    GLOBAL_PARAMETER_RATE = _roadrunner.SelectionRecord_GLOBAL_PARAMETER_RATE
    r"""SelectionType for global parameter rates."""
    REACTION_RATE = _roadrunner.SelectionRecord_REACTION_RATE
    r"""



    """
    INITIAL_AMOUNT = _roadrunner.SelectionRecord_INITIAL_AMOUNT
    r"""SelectionType for initial species amounts."""
    INITIAL_FLOATING_AMOUNT = _roadrunner.SelectionRecord_INITIAL_FLOATING_AMOUNT
    r"""



    """
    INITIAL_BOUNDARY_AMOUNT = _roadrunner.SelectionRecord_INITIAL_BOUNDARY_AMOUNT
    r"""SelectionType for initial boundary species amounts."""
    INITIAL_CONCENTRATION = _roadrunner.SelectionRecord_INITIAL_CONCENTRATION
    r"""SelectionType for initial species concentrations."""
    INITIAL_FLOATING_CONCENTRATION = _roadrunner.SelectionRecord_INITIAL_FLOATING_CONCENTRATION
    r"""



    """
    INITIAL_BOUNDARY_CONCENTRATION = _roadrunner.SelectionRecord_INITIAL_BOUNDARY_CONCENTRATION
    r"""SelectionType for initial floating species concentrations."""
    INITIAL_COMPARTMENT = _roadrunner.SelectionRecord_INITIAL_COMPARTMENT
    r"""SelectionType for initial compartment values."""
    INITIAL_GLOBAL_PARAMETER = _roadrunner.SelectionRecord_INITIAL_GLOBAL_PARAMETER
    r"""SelectionType for initial global parameter values."""
    DEPENDENT_INITIAL_GLOBAL_PARAMETER = _roadrunner.SelectionRecord_DEPENDENT_INITIAL_GLOBAL_PARAMETER
    r"""SelectionType for global parameters that have initial assignment rules."""
    UNSCALED_ELASTICITY = _roadrunner.SelectionRecord_UNSCALED_ELASTICITY
    r"""



    """
    UNSCALED_CONTROL = _roadrunner.SelectionRecord_UNSCALED_CONTROL
    r"""



    """
    UNKNOWN_ELEMENT = _roadrunner.SelectionRecord_UNKNOWN_ELEMENT
    r"""



    """
    ALL_INDEPENDENT = _roadrunner.SelectionRecord_ALL_INDEPENDENT
    r"""



    """
    ALL_DEPENDENT = _roadrunner.SelectionRecord_ALL_DEPENDENT
    r"""



    """
    ALL_INDEPENDENT_AMOUNT = _roadrunner.SelectionRecord_ALL_INDEPENDENT_AMOUNT
    r"""



    """
    ALL_DEPENDENT_AMOUNT = _roadrunner.SelectionRecord_ALL_DEPENDENT_AMOUNT
    r"""



    """
    ALL_INDEPENDENT_CONCENTRATION = _roadrunner.SelectionRecord_ALL_INDEPENDENT_CONCENTRATION
    r"""



    """
    ALL_DEPENDENT_CONCENTRATION = _roadrunner.SelectionRecord_ALL_DEPENDENT_CONCENTRATION
    r"""



    """
    MODEL_STATE = _roadrunner.SelectionRecord_MODEL_STATE
    r"""
    The combination of values that uniquely define the current state of
    the sbml model.

    Note, any sbml variable can be defined by a rule, the model state
    is defined as the set of variabls that define the current state of the
    model. These do not include the initial values as the initial values
    can not be changed by advancing the model with the integrator. (Unused)
    """
    SBML_INITIALIZE = _roadrunner.SelectionRecord_SBML_INITIALIZE
    r"""
    If this bit is set, then the reset function evaluates all of the
    SBML model init conditions (init values and all init assignment rules),
    and assigns them to the model state variable. This setting brings
    the model back the originally loaded state.
    """
    index = property(_roadrunner.SelectionRecord_index_get, _roadrunner.SelectionRecord_index_set, doc=r"""

    :annotation: int

    """)
    p1 = property(_roadrunner.SelectionRecord_p1_get, _roadrunner.SelectionRecord_p1_set, doc=r"""

    :annotation: str

    """)
    p2 = property(_roadrunner.SelectionRecord_p2_get, _roadrunner.SelectionRecord_p2_set, doc=r"""

    :annotation: str

    """)
    selectionType = property(_roadrunner.SelectionRecord_selectionType_get, _roadrunner.SelectionRecord_selectionType_set, doc=r"""the type of selection.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Selections really should be constructed by the RoadRunner::createSelection
        method.

        This just creates a new ebmpy selection.

        |

        *Overload 2:*

        creates a empty selection.
        """
        _roadrunner.SelectionRecord_swiginit(self, _roadrunner.new_SelectionRecord(*args))

    def to_string(self) -> "std::string":
        r"""
        get a short description of this selection, this returns a std::string
        compatable with RoadRunner::createSelection.
        """
        return _roadrunner.SelectionRecord_to_string(self)

    def to_repr(self) -> "std::string":
        r"""
        gets a longer description of this selection, this is intended
        to called as a python __repr__
        """
        return _roadrunner.SelectionRecord_to_repr(self)

    def __repr__(self) -> "std::string":
        return _roadrunner.SelectionRecord___repr__(self)

    def __str__(self) -> "std::string":
        return _roadrunner.SelectionRecord___str__(self)
    __swig_destroy__ = _roadrunner.delete_SelectionRecord

# Register SelectionRecord in _roadrunner:
_roadrunner.SelectionRecord_swigregister(SelectionRecord)


def __lshift__(*args) -> "std::ostream &":
    return _roadrunner.__lshift__(*args)
class PyConservedMoietyConverter(object):
    r"""
    a thin wrapper for python access. In the next release, we will
    use the native SWIG wrapped libsbml api.

    This is only for the python wrappers and should not be used anywhere else.

    In the roadrunner namespace as the SWIG puts everhthing here and the
    generated docs are currently set up to use this namespace.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _roadrunner.PyConservedMoietyConverter_swiginit(self, _roadrunner.new_PyConservedMoietyConverter())
    __swig_destroy__ = _roadrunner.delete_PyConservedMoietyConverter

    def setDocument(self, fileOrPath: "std::string const &") -> "int":
        r"""

        PyConservedMoietyConverter.setDocument(sbmlOrURI)

        Sets the source document. This may be either the contents of an sbml docment
        as a string, or the path the the file.

        :param str sbmlOrURI: contents or path of source document
        :returns: an integer indicating success or failure, 0 means success.
        :rtype: int

        """
        return _roadrunner.PyConservedMoietyConverter_setDocument(self, fileOrPath)

    def convert(self) -> "int":
        r"""

        PyConservedMoietyConverter.convert()

        Perform the document conversion.

        :returns: an integer indicating success or failure, 0 means success.
        :rtype: int

        """
        return _roadrunner.PyConservedMoietyConverter_convert(self)

    def getDocument(self) -> "std::string":
        r"""

        PyConservedMoietyConverter.getDocument()

        Get the converted document contents.

        :returns: The contents of the converted document, or empty string
                  if there is no source document.

        """
        return _roadrunner.PyConservedMoietyConverter_getDocument(self)

# Register PyConservedMoietyConverter in _roadrunner:
_roadrunner.PyConservedMoietyConverter_swigregister(PyConservedMoietyConverter)

class RegistrationFactory(object):
    r"""
    Author: JKM, WBC
    Constructs new integrators
    Implements the factory and singleton patterns.
    Constructs a new integrator given the name (e.g. cvode, gillespie)
    and returns a base pointer to 'rr::Integrator'.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_RegistrationFactory

    def New(self, name: "std::string const &", m: "ExecutableModel") -> "rr::Solver *":
        r"""
        Author: JKM, WBC
        Constructs a new integrator given the name
        (e.g. cvode, gillespie)
        """
        return _roadrunner.RegistrationFactory_New(self, name, m)

    def registerSolver(self, i: "Registrable *") -> "void":
        r"""
        Author: JKM, WBC
        Registers a new integrator with the factory
        so that it can be constructed
        Should be called at startup for new integrators.
        """
        return _roadrunner.RegistrationFactory_registerSolver(self, i)

    def size(self) -> "std::size_t":
        return _roadrunner.RegistrationFactory_size(self)

    def name(self, n: "std::size_t") -> "std::string":
        return _roadrunner.RegistrationFactory_name(self, n)

    def hint(self, n: "std::size_t") -> "std::string":
        return _roadrunner.RegistrationFactory_hint(self, n)

    def description(self, n: "std::size_t") -> "std::string":
        return _roadrunner.RegistrationFactory_description(self, n)

# Register RegistrationFactory in _roadrunner:
_roadrunner.RegistrationFactory_swigregister(RegistrationFactory)

class Registrable(object):
    r"""
    Author: JKM, WBC
    Handles constructing a solver and contains meta
    information about it
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_Registrable

    def getName(self) -> "std::string":
        r"""
        Author: JKM, WBC
        Gets the name associated with this Solver type
        """
        return _roadrunner.Registrable_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: JKM, WBC
        Gets the description associated with this Solver type
        """
        return _roadrunner.Registrable_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: JKM, WBC
        Gets the hint associated with this Solver type
        """
        return _roadrunner.Registrable_getHint(self)

    def construct(self, model: "ExecutableModel") -> "rr::Solver *":
        r"""
        Author: JKM, WBC
        Constructs a new Solver of a given type
        the caller is responsible for deleting
        memory associated with the returned Solver*.
        """
        return _roadrunner.Registrable_construct(self, model)

# Register Registrable in _roadrunner:
_roadrunner.Registrable_swigregister(Registrable)

class Solver(Registrable):
    r"""
    Author: JKM
    Base class for all integrators and steady state solvers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getName(self) -> "std::string":
        r"""
        Author: JKM, WBC
        Gets the name associated with this Solver type
        """
        return _roadrunner.Solver_getName(self)
    __swig_destroy__ = _roadrunner.delete_Solver

    def updateSettings(self, inputSettings: "Dictionary") -> "void":
        r"""
        Update settings values
        update the values of keys in :type inputSettings: :py:class:`Dictionary`
        :param inputSettings:
            with the values. Keys that are not in Solver are ignored
        """
        return _roadrunner.Solver_updateSettings(self, inputSettings)

    def getSettings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Author: JKM
        Get a list of all settings for this solver
        """
        return _roadrunner.Solver_getSettings(self)

    def getSettingsMap(self) -> "std::unordered_map< std::string,Setting,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,Setting > > > &":
        r"""
        get settings for this solver
        :rtype: std::unordered_map< std::string,Setting,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,Setting > > >
        :return: mapping of keys which are setting names
            to values stored as Variants.
        See also: getSettings
        """
        return _roadrunner.Solver_getSettingsMap(self)

    def resetSettings(self) -> "void":
        r"""Reset all settings to their respective default values"""
        return _roadrunner.Solver_resetSettings(self)

    def getValue(self, key: "std::string const &") -> "Setting":
        r"""
        Author: JKM, WBC
        Get the value of an integrator setting
        Notes: Use one of the type-concrete versions like 'getValueAsInt'
        to avoid type conversion gotchas
        """
        return _roadrunner.Solver_getValue(self, key)

    def hasValue(self, key: "std::string const &") -> "Setting":
        r"""
        Author: JKM
        Return true if this setting is supported by the integrator
        """
        return _roadrunner.Solver_hasValue(self, key)

    def getNumParams(self) -> "size_t":
        r"""
        Author: JKM
        Get the number of parameters
        """
        return _roadrunner.Solver_getNumParams(self)

    def getParamName(self, n: "size_t") -> "std::string":
        r"""
        Author: JKM
        Get the name of the parameter at index n
        """
        return _roadrunner.Solver_getParamName(self, n)

    def getParamDisplayName(self, n: "int") -> "std::string":
        r"""
        Author: JKM
        Get the display name of the parameter at index n
        """
        return _roadrunner.Solver_getParamDisplayName(self, n)

    def getParamHint(self, n: "int") -> "std::string":
        r"""
        Author: JKM
        Get the hint of the parameter at index n
        """
        return _roadrunner.Solver_getParamHint(self, n)

    def getParamDesc(self, n: "int") -> "std::string":
        r"""
        Author: JKM
        Get the description of the parameter at index n
        """
        return _roadrunner.Solver_getParamDesc(self, n)

    def getValueAsString(self, key: "std::string const &") -> "std::string":
        r"""
        Author: WBC, JKM
        Wrapper for 'getValue' which converts output to a specific type
        """
        return _roadrunner.Solver_getValueAsString(self, key)

    def setValue(self, key: "std::string const &", value: "Setting") -> "void":
        return _roadrunner.Solver_setValue(self, key, value)

    def getSettingsRepr(self) -> "std::string":
        r"""
        Author: JKM
        Get the solver settings as a std::string
        """
        return _roadrunner.Solver_getSettingsRepr(self)

    def settingsPyDictRepr(self) -> "std::string":
        r"""
        Author: JKM
        Python dictionary-style std::string representation of settings
        """
        return _roadrunner.Solver_settingsPyDictRepr(self)

    def toString(self) -> "std::string":
        r"""
        Author: JKM
        Return a std::string representation of the solver
        """
        return _roadrunner.Solver_toString(self)

    def toRepr(self) -> "std::string":
        r"""
        Author: JKM
        Return std::string representation a la Python __repr__ method
        """
        return _roadrunner.Solver_toRepr(self)

    def getDisplayName(self, key: "std::string const &") -> "std::string const &":
        r"""
        Author: WBC
        Gets the hint associated with a given key
        """
        return _roadrunner.Solver_getDisplayName(self, key)

    def getHint(self, *args) -> "std::string const &":
        r"""
        *Overload 1:*

        Author: JKM, WBC
        Gets the hint associated with this Solver type

        |

        *Overload 2:*

        Author: WBC
        Gets the hint associated with a given key
        """
        return _roadrunner.Solver_getHint(self, *args)

    def getDescription(self, *args) -> "std::string const &":
        r"""
        *Overload 1:*

        Author: JKM, WBC
        Gets the description associated with this Solver type

        |

        *Overload 2:*

        Author: WBC
        Gets the description associated with a given key
        """
        return _roadrunner.Solver_getDescription(self, *args)

    def getType(self, key: "std::string const &") -> "Setting::TypeId":
        r"""
        Author: WBC
        Gets the type associated with a given key
        """
        return _roadrunner.Solver_getType(self, key)

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.Solver_syncWithModel(self, m)

    def getModel(self) -> "rr::ExecutableModel *":
        r"""returns the pointer to the ExecutableModel"""
        return _roadrunner.Solver_getModel(self)
    sorted_settings = property(_roadrunner.Solver_sorted_settings_get, _roadrunner.Solver_sorted_settings_set)
    settings = property(_roadrunner.Solver_settings_get, _roadrunner.Solver_settings_set)
    display_names_ = property(_roadrunner.Solver_display_names__get, _roadrunner.Solver_display_names__set)
    hints = property(_roadrunner.Solver_hints_get, _roadrunner.Solver_hints_set)
    descriptions = property(_roadrunner.Solver_descriptions_get, _roadrunner.Solver_descriptions_set)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if name in self.getSettings():
            return Solver.getValue(self, name)
        else:
            return self.__dict__[name]

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            self.__dict__[name] = value

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)

    def setValues(self, keys, values):
        for key, val in zip(keys, values):
            _roadrunner.Solver_setValue(self, key, val)


# Register Solver in _roadrunner:
_roadrunner.Solver_swigregister(Solver)

class Integrator(Solver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setValue(self, key: "std::string const &", value: "Setting") -> "void":
        return _roadrunner.Integrator_setValue(self, key, value)
    Deterministic = _roadrunner.Integrator_Deterministic
    Stochastic = _roadrunner.Integrator_Stochastic
    Hybrid = _roadrunner.Integrator_Hybrid
    Other = _roadrunner.Integrator_Other
    __swig_destroy__ = _roadrunner.delete_Integrator

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        return _roadrunner.Integrator_getIntegrationMethod(self)

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.Integrator_syncWithModel(self, m)

    def loadConfigSettings(self) -> "void":
        return _roadrunner.Integrator_loadConfigSettings(self)

    def loadSBMLSettings(self, filename: "std::string const &") -> "void":
        return _roadrunner.Integrator_loadSBMLSettings(self, filename)

    def integrate(self, t0: "double", hstep: "double") -> "double":
        return _roadrunner.Integrator_integrate(self, t0, hstep)

    def restart(self, t0: "double") -> "void":
        return _roadrunner.Integrator_restart(self, t0)

    def tweakTolerances(self) -> "void":
        r"""
        Author: JKM, WBC, ETS, MTK
        Fix tolerances for SBML tests
        In order to ensure that the results of the SBML test suite
        remain valid, this method enforces a lower bound on tolerance values.
        Sets minimum absolute and relative tolerances to
        Config::CVODE_MIN_ABSOLUTE and Config::CVODE_MIN_RELATIVE resp.
        """
        return _roadrunner.Integrator_tweakTolerances(self)

    def setIndividualTolerance(self, sid: "std::string", value: "double") -> "void":
        r"""
        Author: FY
        Set tolerance for floating species or variables that have a rate rule, will only be used in CVODEIntegrator
        """
        return _roadrunner.Integrator_setIndividualTolerance(self, sid, value)

    def setConcentrationTolerance(self, value: "Setting") -> "void":
        r"""
        Author: FY
        Set tolerance based on concentration of species, will only be used in CVODEIntegrator
        """
        return _roadrunner.Integrator_setConcentrationTolerance(self, value)

    def getConcentrationTolerance(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Author: FY
        Get tolerance based on concentration of species, will only be used in CVODEIntegrator
        """
        return _roadrunner.Integrator_getConcentrationTolerance(self)

    def setListener(self, arg2: "rr::IntegratorListenerPtr") -> "void":
        return _roadrunner.Integrator_setListener(self, arg2)

    def __str__(self) -> "std::string":
        return _roadrunner.Integrator___str__(self)

    def toRepr(self) -> "std::string":
        r"""
        Author: JKM
        Return std::string representation a la Python __repr__ method
        """
        return _roadrunner.Integrator_toRepr(self)

    def setIntegrationStartTime(self, time: "double") -> "void":
        return _roadrunner.Integrator_setIntegrationStartTime(self, time)

    def _setListener(self, listener: "rr::PyIntegratorListenerPtr const &") -> "void":
        return _roadrunner.Integrator__setListener(self, listener)

    def _getListener(self) -> "rr::PyIntegratorListenerPtr":
        return _roadrunner.Integrator__getListener(self)

    def _clearListener(self) -> "void":
        return _roadrunner.Integrator__clearListener(self)

    def getListener(self):
        return self._getListener()

    def setListener(self, listener):
        if listener is None:
            self._clearListener()
        else:
            self._setListener(listener)

    listener = property(getListener, setListener)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if(name in self.getSettings()):
            return Solver.getValue(self, name)
        else:
            return self.__dict__[name]

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            self.__dict__[name] = value

    def __repr__(self):
        return self.toRepr()

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)


# Register Integrator in _roadrunner:
_roadrunner.Integrator_swigregister(Integrator)

class IntegratorException(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _roadrunner.IntegratorException_swiginit(self, _roadrunner.new_IntegratorException(*args))
    __swig_destroy__ = _roadrunner.delete_IntegratorException

# Register IntegratorException in _roadrunner:
_roadrunner.IntegratorException_swigregister(IntegratorException)

class SteadyStateSolver(Solver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SteadyStateSolver

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.SteadyStateSolver_syncWithModel(self, m)

    def solve(self) -> "double":
        return _roadrunner.SteadyStateSolver_solve(self)

    def loadConfigSettings(self) -> "void":
        return _roadrunner.SteadyStateSolver_loadConfigSettings(self)

    def __str__(self) -> "std::string":
        r"""
        Author: KC
        Return a std::string representation of the solver
        """
        return _roadrunner.SteadyStateSolver___str__(self)

    def toRepr(self) -> "std::string":
        r"""
        Author: KC
        Return std::string representation a la Python __repr__ method
        """
        return _roadrunner.SteadyStateSolver_toRepr(self)

    def resetSettings(self) -> "void":
        r"""
        Implements settings shared by
        all steady state solvers.
        """
        return _roadrunner.SteadyStateSolver_resetSettings(self)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if(name in self.getSettings()):
            return Solver.getValue(self, name)
        else:
            return self.__dict__[name]

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            self.__dict__[name] = value

    def __repr__(self):
        return self.toRepr()

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)


# Register SteadyStateSolver in _roadrunner:
_roadrunner.SteadyStateSolver_swigregister(SteadyStateSolver)

class SensitivitySolver(Solver):
    r"""generic interface for all SensitivitySolvers"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SensitivitySolver

    def getSensitivityMatrix(self, k: "int"=0) -> "rr::Matrix< double >":
        r"""
        get current values of sensitivities of model variables
        to parameters.
        :param kth: derivative of the sensitivities.
        """
        return _roadrunner.SensitivitySolver_getSensitivityMatrix(self, k)

# Register SensitivitySolver in _roadrunner:
_roadrunner.SensitivitySolver_swigregister(SensitivitySolver)

class TimeSeriesSensitivitySolver(SensitivitySolver):
    r"""
    generic interface for sensitivity solvers that
    integrate the model and compute sensitivities at
    each time point
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_TimeSeriesSensitivitySolver

    def integrate(self, t0: "double", hstep: "double") -> "double":
        r"""
        integrate the model from t0 to t0 + hstep.
        Notes: this signature is the same as that found in
        Integrator().
        integrating the model should update the
        sensitivities, which are available from getSensitivities()
        """
        return _roadrunner.TimeSeriesSensitivitySolver_integrate(self, t0, hstep)

    def solveSensitivities(self, start: "double", stop: "double", num: "int", params: "std::vector< std::string,std::allocator< std::string > >", species: "std::vector< std::string,std::allocator< std::string > >", k: "int") -> "rr::Matrix3D< double,double >":
        r"""
        simulate a timeseries with sensitivities from start to step with num
        data points.
        Matrix3D indexed by time. Each element of the 3D matrix is a
        Matrix<double> with rows and columns parameters and model variables respectively.
        The parameter k determines the kth order derivative of the sensitivity information
        that will be returned
        :type start: float
        :param start: starting time for time series simulation
        :type stop: float
        :param stop: last time point for time series simulation
        :type num: int
        :param num: number of data points to simulate. Determines Z of Matrix3D.
        :type params: std::vector< std::string,std::allocator< std::string > >
        :param params: vector of parameters that you want sensitivity for. When empty (default), compute
            sensitivities for all parameters vs all variables.
        :type species: std::vector< std::string,std::allocator< std::string > >
        :param species: vector of species to include in the results.
            Note that unlike for :type params: std::vector< std::string,std::allocator< std::string > >
        :param params:, reducing the number of
            species does not solve faster because the matrix slicing only
            occurs at the end. When empty (default) all species are returned.
        :type k: int
        :param k: (default 0) return the kth other derivative of the sensitivity data.
        """
        return _roadrunner.TimeSeriesSensitivitySolver_solveSensitivities(self, start, stop, num, params, species, k)

# Register TimeSeriesSensitivitySolver in _roadrunner:
_roadrunner.TimeSeriesSensitivitySolver_swigregister(TimeSeriesSensitivitySolver)

class SteadyStateSensitivitySolver(SensitivitySolver):
    r"""
    genetic interface for sensitivity solvers that
    solve for steady state before computing model sensitivities
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SteadyStateSensitivitySolver

    def solveSteadyState(self) -> "double":
        r"""
        solves the model for steady state.
        this method is called prior to computing sensitivities
        to get sensitivities at steady state.
        """
        return _roadrunner.SteadyStateSensitivitySolver_solveSteadyState(self)

    def solveSensitivities(self, *args, **kwargs) -> "rr::Matrix< double >":
        r"""
        compute sensitivities at steady state
        :type params: std::vector< std::string,std::allocator< std::string > >, optional
        :param params: which parameters do you want sensitivities for? Each
            string must be a valid model parameter. If left empty (default)
            then all model parameters are selected.
        :type k: int, optional
        :param k: returned double matrix will contain the kth order derivative
            of the sensitivities, where 0 (default) is just the sensitivity values
        :rtype: rr::Matrix< double >
        :return: the k'th order derivitive of the Sensitivities for this model
            at steady state. Rows (number of model variables), columns (Np, number
            of parameters user has requested sensitivites for).
        """
        return _roadrunner.SteadyStateSensitivitySolver_solveSensitivities(self, *args, **kwargs)

# Register SteadyStateSensitivitySolver in _roadrunner:
_roadrunner.SteadyStateSensitivitySolver_swigregister(SteadyStateSensitivitySolver)

class PyEventListener(EventListener):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _roadrunner.PyEventListener_swiginit(self, _roadrunner.new_PyEventListener())
    __swig_destroy__ = _roadrunner.delete_PyEventListener

    def setOnTrigger(self, py: "PyObject *") -> "void":
        return _roadrunner.PyEventListener_setOnTrigger(self, py)

    def getOnTrigger(self) -> "PyObject *":
        return _roadrunner.PyEventListener_getOnTrigger(self)

    def setOnAssignment(self, py: "PyObject *") -> "void":
        return _roadrunner.PyEventListener_setOnAssignment(self, py)

    def getOnAssignment(self) -> "PyObject *":
        return _roadrunner.PyEventListener_getOnAssignment(self)

    def fireOnTrigger(self, model: "ExecutableModel", index: "size_t", eventId: "std::string const &") -> "void":
        return _roadrunner.PyEventListener_fireOnTrigger(self, model, index, eventId)

    def fireOnAssignment(self, model: "ExecutableModel", index: "size_t", eventId: "std::string const &") -> "void":
        return _roadrunner.PyEventListener_fireOnAssignment(self, model, index, eventId)

    onTrigger = property(getOnTrigger, setOnTrigger)

    onAssignment = property(getOnAssignment, setOnAssignment)


# Register PyEventListener in _roadrunner:
_roadrunner.PyEventListener_swigregister(PyEventListener)

class PyIntegratorListener(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _roadrunner.PyIntegratorListener_swiginit(self, _roadrunner.new_PyIntegratorListener())
    __swig_destroy__ = _roadrunner.delete_PyIntegratorListener

    def setOnTimeStep(self, py: "PyObject *") -> "void":
        return _roadrunner.PyIntegratorListener_setOnTimeStep(self, py)

    def getOnTimeStep(self) -> "PyObject *":
        return _roadrunner.PyIntegratorListener_getOnTimeStep(self)

    def setOnEvent(self, py: "PyObject *") -> "void":
        return _roadrunner.PyIntegratorListener_setOnEvent(self, py)

    def getOnEvent(self) -> "PyObject *":
        return _roadrunner.PyIntegratorListener_getOnEvent(self)

    onTimeStep = property(getOnTimeStep, setOnTimeStep)

    onEvent = property(getOnEvent, setOnEvent)


# Register PyIntegratorListener in _roadrunner:
_roadrunner.PyIntegratorListener_swigregister(PyIntegratorListener)

class Config(object):
    r"""
    read or store default values.

    Many of RoadRunner classes use a number of configuration parameters. Most of these can be set
    using the Config class. The values stored in the Config class only determine the default values of
    parameters.

    The Config class will look in the following locations for the config file, and will load the
    values from the first config file it finds. If it does not find a config file in one of the
    following locations, a default set of configuration parameters are used. The search locations of
    the config file are:

    #1: the ROADRUNNER_CONFIG environment variable

    #2: try the user's home directory for roadrunner.conf, i.e.:

    /Users/andy/roadrunner.conf

    #3: try the user's home directory for .roadrunner.conf, i.e.:

    /Users/andy/.roadrunner.conf

    #4: try the same directory as the roadrunner shared library, this
    will be the same directory as the python _roadrunner.pyd python extension module, i.e.:

    /Users/andy/local/lib/roadrunner.conf

    #5: try one directory up from the where the shared library or program is at, i.e.:

    /Users/andy/local/roadrunner.conf

    The conf file is just a plain text file of where each line may
    be key / value std::pair separated by a :", i.e.

    KEY_NAME : Value Any line that does not match this format is ignored, and keys that are not found
    are also ignored. Therefore, any line that does not start w* ith a word character is considered a
    comment.

    All of the configuration managment functions are static method of the Config class, and all of
    the configuration keys are static attributes * of the Config class, these are documented in the
    Configuration Functions section.

    As all of the Config class methods are static, one never instantiates the Config class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LOADSBMLOPTIONS_CONSERVED_MOIETIES = _roadrunner.Config_LOADSBMLOPTIONS_CONSERVED_MOIETIES
    r"""

    :annotation: bool

    perform conservation analysis.

    This causes a re-ordering of the species, so results generated
    with this flag enabled can not be compared index wise to results
    generated otherwise.

    Moiety conservation is only compatable with simple models which do NOT have any events or rules
    which define or alter any floating species, and which have simple constant stoichiometries.

    Moiety conservation may cause unexpected results, be aware of what it is before enableing.

    Not recommended for time series simulations.

    """
    LOADSBMLOPTIONS_RECOMPILE = _roadrunner.Config_LOADSBMLOPTIONS_RECOMPILE
    r"""

    :annotation: bool

    Should the model be recompiled?
    The LLVM ModelGenerator maintains a hash table of currently running
    models. If this flag is NOT set, then the generator will look to see
    if there is already a running instance of the given model and
    use the generated code from that one.

    If only a single instance of a model is run, there is no
    need to cache the models, and this can safely be enabled,
    realizing some performance gains.

    """
    LOADSBMLOPTIONS_READ_ONLY = _roadrunner.Config_LOADSBMLOPTIONS_READ_ONLY
    r"""

    :annotation: bool

    If this is set, then a read-only model is generated. A read-only
    model can be simulated, but no code is generated to set model
    values, i.e. parameters, amounts, values, etc...

    It takes a finite amount of time to generate the model value setting
    functions, and if they are not needed, one may see some performance
    gains, especially in very large models.

    """
    LOADSBMLOPTIONS_MUTABLE_INITIAL_CONDITIONS = _roadrunner.Config_LOADSBMLOPTIONS_MUTABLE_INITIAL_CONDITIONS
    r"""

    :annotation: bool

    Generate accessors functions to allow changing of initial
    conditions.

    """
    LOADSBMLOPTIONS_OPTIMIZE_GVN = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_GVN
    r"""

    :annotation: bool

    GVN - This pass performs global value numbering and redundant load
    elimination cotemporaneously.

    """
    LOADSBMLOPTIONS_OPTIMIZE_CFG_SIMPLIFICATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_CFG_SIMPLIFICATION
    r"""

    :annotation: bool

    CFGSimplification - Merge basic blocks, eliminate unreachable blocks,
    simplify terminator instructions, etc...

    """
    LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_COMBINING = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_COMBINING
    r"""

    :annotation: bool

    InstructionCombining - Combine instructions to form fewer, simple
    instructions. This pass does not modify the CFG, and has a tendency to make
    instructions dead, so a subsequent DCE pass is useful.

    """
    LOADSBMLOPTIONS_OPTIMIZE_DEAD_INST_ELIMINATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_DEAD_INST_ELIMINATION
    r"""

    :annotation: bool

    DeadInstElimination - This pass quickly removes trivially dead instructions
    without modifying the CFG of the function.  It is a BasicBlockPass, so it
    runs efficiently when queued next to other BasicBlockPass's.

    """
    LOADSBMLOPTIONS_OPTIMIZE_DEAD_CODE_ELIMINATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_DEAD_CODE_ELIMINATION
    r"""

    :annotation: bool

    DeadCodeElimination - This pass is more powerful than DeadInstElimination,
    because it is worklist driven that can potentially revisit instructions when
    their other instructions become dead, to eliminate chains of dead
    computations.

    """
    LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER
    r"""

    :annotation: bool


    InstructionSimplifier - Remove redundant instructions.

    """
    LOADSBMLOPTIONS_USE_MCJIT = _roadrunner.Config_LOADSBMLOPTIONS_USE_MCJIT
    r"""

    :annotation: bool

    Currently disabled.

    Use the LLVM MCJIT JIT engine.

    Defaults to False.

    The MCJIT is the new LLVM JIT engine, it is not as well tested as the
    original JIT engine. Does NOT work on LLVM 3.1

    """
    SIMULATEOPTIONS_STEPS = _roadrunner.Config_SIMULATEOPTIONS_STEPS
    r"""

    :annotation: int

    The number of steps at which the output is sampled. The samples are evenly spaced.
    When a simulation system calculates the data points to record, it will typically
    divide the duration by the number of time steps. Thus, for N steps, the output
    will have N+1 data rows.

    """
    SIMULATEOPTIONS_DURATION = _roadrunner.Config_SIMULATEOPTIONS_DURATION
    r"""

    :annotation: double

    The duration of the simulation run, in the model's units of time. Note,
    setting the duration automatically sets the end time and visa versa.

    """
    SIMULATEOPTIONS_ABSOLUTE = _roadrunner.Config_SIMULATEOPTIONS_ABSOLUTE
    r"""

    :annotation: double

    The absolute error tolerance used by the integrator.

    A number representing the absolute difference permitted for the integrator
    tolerance. Defaults to 1.000000e-10.

    """
    SIMULATEOPTIONS_RELATIVE = _roadrunner.Config_SIMULATEOPTIONS_RELATIVE
    r"""

    :annotation: double

    The relative error tolerance used by the integrator.

    A float-point number representing the relative difference permitted.
    Defaults to 1.000000e-05.

    """
    SIMULATEOPTIONS_STRUCTURED_RESULT = _roadrunner.Config_SIMULATEOPTIONS_STRUCTURED_RESULT
    r"""

    :annotation: bool

    A boolean option to return a structured array from the RoadRunner.simulate method. Structured
    arrays contain column names and other data. A structured array needs to be converted into regular
    arrays before they can be used in numpy functions.

    """
    SIMULATEOPTIONS_STIFF = _roadrunner.Config_SIMULATEOPTIONS_STIFF
    r"""

    :annotation: bool

    Is the model a stiff system? setting this to stiff causes
    RoadRunner to load a stiff solver which could potentially be
    extremly slow

    """
    SIMULATEOPTIONS_MULTI_STEP = _roadrunner.Config_SIMULATEOPTIONS_MULTI_STEP
    r"""

    :annotation: bool

    The MULTI_STEP option tells the solver to take a series of internal steps
    and then return the solution at the point reached by that step.

    In simulate, this option will likely be slower than normal mode,
    but may be useful to monitor solutions as they are integrated.

    This is intended to be used in combination with the
    IntegratorListener. It this option is set, and there is a
    IntegratorListener set, RoadRunner::integrate will run the
    integrator in a series of internal steps, and the listner
    will by notified at each step.

    Highly Experimental!!!

    """
    SIMULATEOPTIONS_DETERMINISTIC_VARIABLE_STEP = _roadrunner.Config_SIMULATEOPTIONS_DETERMINISTIC_VARIABLE_STEP
    r"""
    Do variable time step integration when using a deterministic
    integrator
    """
    SIMULATEOPTIONS_STOCHASTIC_VARIABLE_STEP = _roadrunner.Config_SIMULATEOPTIONS_STOCHASTIC_VARIABLE_STEP
    r"""
    Do variable time step integration when using stochastic
    integrators.
    """
    SIMULATEOPTIONS_INTEGRATOR = _roadrunner.Config_SIMULATEOPTIONS_INTEGRATOR
    r"""
    Default integrator to use, currently supports a std::string of "CVODE" or "Gillespie",
    default is "CVODE"
    """
    SIMULATEOPTIONS_INITIAL_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_INITIAL_TIMESTEP
    r"""

    :annotation: double

    A user specified initial time step. If this is <=  0, the integrator
    will attempt to determine a safe initial time step.

    Note, for each number of steps given to RoadRunner::simulate or RoadRunner::oneStep,
    the internal integrator may take many many steps to reach one of the external time
    steps. This value specifies an initial value for the internal integrator
    time step.

    """
    SIMULATEOPTIONS_MINIMUM_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_MINIMUM_TIMESTEP
    r"""

    :annotation: double

    Specify The Minimum Time Step That The Internal Integrator
    Will Use. Uses Integrator Estimated Value If <= 0.

    """
    SIMULATEOPTIONS_MAXIMUM_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_MAXIMUM_TIMESTEP
    r"""
    Specify The Maximum Time Step Size That The Internaal Integrator
    Will Use. Uses Integrator Estimated Value If <= 0.
    see SimulateOptions::maximumTimeStep
    """
    SIMULATEOPTIONS_MAXIMUM_NUM_STEPS = _roadrunner.Config_SIMULATEOPTIONS_MAXIMUM_NUM_STEPS
    r"""

    :annotation: int

    Specify The Maximum Number Of Steps The Internal Integrator Will Use
    Before Reaching The User Specified Time Span. Uses The Integrator
    Default Value If <= 0.

    """
    ROADRUNNER_DISABLE_WARNINGS = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS
    r"""

    :annotation: int

    disable SBML conserved moiety warnings.

    Conserved Moiety Conversion may cause unexpected behavior, be aware of what it
    is before enabling.

    RoadRunner will issue a warning in steadyState if conservedMoieties are NOT
    enabled because of a potential singular Jacobian. To disable this warning,
    set this value to 1

    A notice will be issued whenever a document is loaded and conserved moieties
    are enabled. To disable this notice, set this value to 2.

    To disable both the warning and notice, set this value to 3

    Rationale for these numbers: This is actual a bit field, disabling the steady state
    warning value is actually 0b01 << 0 which is 1, and the loading warning is 0b01 << 1
    which is 2 and 0b01 & 0b10 is 0b11 which is 3 in decimal.

    """
    ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES = _roadrunner.Config_ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES
    r"""

    :annotation: int

    RoadRunner by default dynamically generates accessors properties
    for all SBML symbol names on the model object when it is retrieved
    in Python. This feature is very nice for interactive use, but
    can slow things down. If this feature is not needed, it
    can be disabled here.

    """
    SBML_APPLICABLEVALIDATORS = _roadrunner.Config_SBML_APPLICABLEVALIDATORS
    r"""
    a hex value consisting of a combination of the following values:

    IdCheckON         0x01
    IdCheckOFF        0xfe
    SBMLCheckON       0x02
    SBMLCheckOFF      0xfd
    SBOCheckON        0x04
    SBOCheckOFF       0xfb
    MathCheckON       0x08
    MathCheckOFF      0xf7
    UnitsCheckON      0x10
    UnitsCheckOFF     0xef
    OverdeterCheckON  0x20
    OverdeterCheckOFF 0xdf
    PracticeCheckON   0x40
    PracticeCheckOFF  0xbf
    AllChecksON       0x7f

    The default value is AllChecksON & UnitsCheckOFF
    """
    ROADRUNNER_JACOBIAN_STEP_SIZE = _roadrunner.Config_ROADRUNNER_JACOBIAN_STEP_SIZE
    r"""default step size for Jabobian finite differece calculations"""
    MODEL_RESET = _roadrunner.Config_MODEL_RESET
    r"""
    A bitfield (unsigned integer) consisting of the values in
    SelectionRecord::SelectionType.

    This value determines which values of the model are reset
    to their origin SBML specified values.

    Current valid values can be a combination of:

    SelectionRecord::SelectionType::TIME,
    SelectionRecord::SelectionType::RATE,
    SelectionRecord::SelectionType::BOUNDARY,
    SelectionRecord::SelectionType::FLOATING,
    SelectionRecord::SelectionType::GLOBAL_PARAMETER,
    SelectionRecord::SelectionType::CONSREVED_MOIETY,
    SelectionRecord::SelectionType::COMPARTMENT,
    SelectionRecord::SelectionType::ALL.

    Note, if RATE is specified, this will cause all global parameters
    defined by rate rules to be reset, even if GLOBAL_PARAMETER is NOT
    specified.

    The default value is TIME | RATE | FLOATING
    """
    CVODE_MIN_ABSOLUTE = _roadrunner.Config_CVODE_MIN_ABSOLUTE
    r"""
    The minumum absolute error that the CVODE integrator supports
    in order to to pass the sbml test suite using the default integtator.

    If a test suite config file is loaded, and the relative error is
    higher than CVODE_MIN_ABSOLUTE, it should be lowered to CVODE_MIN_ABSOLUTE.
    """
    CVODE_MIN_RELATIVE = _roadrunner.Config_CVODE_MIN_RELATIVE
    r"""
    The minumum relative error that the CVODE integrator supports
    in order to to pass the sbml test suite using the default integtator.

    If a test suite config file is loaded, and the relative error is
    higher than CVODE_MIN_RELATIVE, it should be lowered to CVODE_MIN_RELATIVE.
    """
    SIMULATEOPTIONS_COPY_RESULT = _roadrunner.Config_SIMULATEOPTIONS_COPY_RESULT
    r"""make a copy of the simulation result in Python."""
    STEADYSTATE_PRESIMULATION = _roadrunner.Config_STEADYSTATE_PRESIMULATION
    r"""Flag for starting steady state analysis with simulation."""
    STEADYSTATE_PRESIMULATION_MAX_STEPS = _roadrunner.Config_STEADYSTATE_PRESIMULATION_MAX_STEPS
    r"""Maximum number of steps that can be taken for presimulation before steady state analysis."""
    STEADYSTATE_PRESIMULATION_TIME = _roadrunner.Config_STEADYSTATE_PRESIMULATION_TIME
    r"""End time for presimulation steady state analysis."""
    STEADYSTATE_APPROX = _roadrunner.Config_STEADYSTATE_APPROX
    r"""Flag for using steady state approximation routine when steady state solver fails."""
    STEADYSTATE_APPROX_TOL = _roadrunner.Config_STEADYSTATE_APPROX_TOL
    r"""Tolerance for steady state approximation routine."""
    STEADYSTATE_APPROX_MAX_STEPS = _roadrunner.Config_STEADYSTATE_APPROX_MAX_STEPS
    r"""Maximum number of steps that can be taken for steady state approximation routine."""
    STEADYSTATE_APPROX_TIME = _roadrunner.Config_STEADYSTATE_APPROX_TIME
    r"""End time for steady state approximation routine."""
    STEADYSTATE_RELATIVE = _roadrunner.Config_STEADYSTATE_RELATIVE
    r"""Specifies the relative tolerance."""
    STEADYSTATE_MAXIMUM_NUM_STEPS = _roadrunner.Config_STEADYSTATE_MAXIMUM_NUM_STEPS
    r"""Maximum number of steps for steady state solvers."""
    STEADYSTATE_MINIMUM_DAMPING = _roadrunner.Config_STEADYSTATE_MINIMUM_DAMPING
    r"""Minimum damping factor for steady state solvers."""
    STEADYSTATE_BROYDEN = _roadrunner.Config_STEADYSTATE_BROYDEN
    r"""Switches on Broyden method."""
    STEADYSTATE_LINEARITY = _roadrunner.Config_STEADYSTATE_LINEARITY
    r"""Specifies linearity of the problem."""
    ROADRUNNER_JACOBIAN_MODE = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE
    r"""
    Determines the mode that the RoadRunner Jacobian calculations will be
    be performed in.  The Jacobian can be calculated either with respect to
    amounts or concentrations. Default is concentrations.

    This can be either ROADRUNNER_JACOBIAN_MODE_AMOUNTS or
    ROADRUNNER_JACOBIAN_MODE_CONCENTRATIONS.
    """
    TEMP_DIR_PATH = _roadrunner.Config_TEMP_DIR_PATH
    r"""
    Directory path where roadrunner should store temp files. If empty, the
    system specified temp dir is used. Paths may have enviormnent variables, i.e.
    ${HOME}/tmp

    May have environment variables contained in the path.
    On Unix, a tilde as first character in the path is
    replaced with the path to user's home directory.
    """
    LOGGER_LOG_FILE_PATH = _roadrunner.Config_LOGGER_LOG_FILE_PATH
    r"""
    Path to where the logger should write a roadrunner log file. If no path
    is specified, the log file will be written as a "roadrunner.log" in the
    temp dir.

    May have environment variables contained in the path.
    On Unix, a tilde as first character in the path is
    replaced with the path to user's home directory.
    """
    RANDOM_SEED = _roadrunner.Config_RANDOM_SEED
    r"""
    Seed for random numbers, should be a integer.

    If this value is negative, then the system time is used
    for the random seed.
    """
    PYTHON_ENABLE_NAMED_MATRIX = _roadrunner.Config_PYTHON_ENABLE_NAMED_MATRIX
    r"""
    use new numpy arrays with row/column names
    experimental
    """
    LLVM_SYMBOL_CACHE = _roadrunner.Config_LLVM_SYMBOL_CACHE
    r"""cache llvm symbols durring sbml compilation."""
    OPTIMIZE_REACTION_RATE_SELECTION = _roadrunner.Config_OPTIMIZE_REACTION_RATE_SELECTION
    r"""optimize reaction rate selection durring integration."""
    LOADSBMLOPTIONS_PERMISSIVE = _roadrunner.Config_LOADSBMLOPTIONS_PERMISSIVE
    r"""
    Relax SBML resrictions.

    Allows some idiosyncrasies of e.g. JDesigner that libSBML does not
    officially support. See:
    https://groups.google.com/forum/#!topic/sbml-discuss/u3NK14RUHvE

    Specifics: allows use time in user-defined functions, allows use of
    booleans in scalars
    """
    MAX_OUTPUT_ROWS = _roadrunner.Config_MAX_OUTPUT_ROWS
    r"""
    Set the maximum number of rows in the output matrix.

    When simulate is called with variable stepping and tight
    tolerances the resulting output matrix will be very large.
    This setting cuts off the computation after a certain number
    of rows are reached.
    """
    ALLOW_EVENTS_IN_STEADY_STATE_CALCULATIONS = _roadrunner.Config_ALLOW_EVENTS_IN_STEADY_STATE_CALCULATIONS
    r"""
    Enable or disable steady state calculations when a model contains events

    If true, steady state calculations will be carried out irrespective of
    whether events are present or not.

    If false, steady state calculations will not be carried out in the
    presence of events.
    """
    VALIDATION_IN_REGENERATION = _roadrunner.Config_VALIDATION_IN_REGENERATION
    K_ROWS_PER_WRITE = _roadrunner.Config_K_ROWS_PER_WRITE
    CONFIG_END = _roadrunner.Config_CONFIG_END
    r"""
    Needs to be the last item in the enum, no mater how many
    other items are added, this is used internally to create
    a static array.
    """
    ROADRUNNER_DISABLE_WARNINGS_STEADYSTATE = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS_STEADYSTATE
    ROADRUNNER_DISABLE_WARNINGS_CONSERVED_MOIETY = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS_CONSERVED_MOIETY
    ROADRUNNER_JACOBIAN_MODE_AMOUNTS = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE_AMOUNTS
    ROADRUNNER_JACOBIAN_MODE_CONCENTRATIONS = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE_CONCENTRATIONS

    @staticmethod
    def getConfigFilePath() -> "std::string":
        r"""

        Config.getConfigFilePath()

        If roadrunner was able to find a configuration file on the file system, its full path is returned
        here. If no file was found, this returns a empty string.

        """
        return _roadrunner.Config_getConfigFilePath()

    @staticmethod
    def setValue(arg1: "rr::Config::Keys", value: "Setting") -> "void":
        r"""

        Config.setValue(key, value)

        Set the value of a configuration key. The value must be either a string, integer, double or
        boolean. If one wanted to change the value of the default integrator tolerances, one would::

          from roadrunner import Config
          Config.setValue(Config.SIMULATEOPTIONS_ABSOLUTE, 3.14e-12)
          Config.setValue(Config.SIMULATEOPTIONS_RELATIVE, 2.78e-5)


        Or, other options may be set to Boolean or integer values. To enable an optimization features,
        or to set default simulation time steps::

          Config.setValue(Config.LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER, True)
          Config.setValue(Config.SIMULATEOPTIONS_STEPS, 100)

        """
        return _roadrunner.Config_setValue(arg1, value)

    @staticmethod
    def getValue(arg1: "rr::Config::Keys") -> "Setting":
        return _roadrunner.Config_getValue(arg1)

    @staticmethod
    def readConfigFile(path: "std::string const &") -> "void":
        r"""

        Config.readConfigFile(path)

        Read all of the values from a configuration file at the given path. This overrides any previously
        stored configuration. This allows users to have any number of configuration files and load them
        at any time. Say someone had to use Windows, and they had a file in thier C: drive, this would be
        loaded via::

          Config.readConfigFile("C:/my_config_file.txt")

        Note, the forward slash works on both Unix and Windows, using the forward slash eliminates the
        need to use a double back slash, "\\\\\\\\".

        """
        return _roadrunner.Config_readConfigFile(path)

    @staticmethod
    def writeConfigFile(path: "std::string const &") -> "void":
        r"""

        Config.writeConfigFile(path)

        Write all of the current configuration values to a file. This could be written to one of the
        default locations, or to any other location, and re-loaded at a later time.



        Available Configuration Parameters
        ----------------------------------
        All of the configuration parameter keys are static attributes of the Config class and are listed
        here. The variable type of the parameter is listed after the key name.

        """
        return _roadrunner.Config_writeConfigFile(path)

    @staticmethod
    def stringToKey(key: "std::string const &") -> "rr::Config::Keys":
        return _roadrunner.Config_stringToKey(key)

    @staticmethod
    def getKeyList() -> "std::vector< std::string,std::allocator< std::string > >":
        return _roadrunner.Config_getKeyList()

    def __init__(self):
        _roadrunner.Config_swiginit(self, _roadrunner.new_Config())
    __swig_destroy__ = _roadrunner.delete_Config

# Register Config in _roadrunner:
_roadrunner.Config_swigregister(Config)

def Config_getConfigFilePath() -> "std::string":
    r"""

    Config.getConfigFilePath()

    If roadrunner was able to find a configuration file on the file system, its full path is returned
    here. If no file was found, this returns a empty string.

    """
    return _roadrunner.Config_getConfigFilePath()

def Config_setValue(arg1: "rr::Config::Keys", value: "Setting") -> "void":
    r"""

    Config.setValue(key, value)

    Set the value of a configuration key. The value must be either a string, integer, double or
    boolean. If one wanted to change the value of the default integrator tolerances, one would::

      from roadrunner import Config
      Config.setValue(Config.SIMULATEOPTIONS_ABSOLUTE, 3.14e-12)
      Config.setValue(Config.SIMULATEOPTIONS_RELATIVE, 2.78e-5)


    Or, other options may be set to Boolean or integer values. To enable an optimization features,
    or to set default simulation time steps::

      Config.setValue(Config.LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER, True)
      Config.setValue(Config.SIMULATEOPTIONS_STEPS, 100)

    """
    return _roadrunner.Config_setValue(arg1, value)

def Config_getValue(arg1: "rr::Config::Keys") -> "Setting":
    return _roadrunner.Config_getValue(arg1)

def Config_readConfigFile(path: "std::string const &") -> "void":
    r"""

    Config.readConfigFile(path)

    Read all of the values from a configuration file at the given path. This overrides any previously
    stored configuration. This allows users to have any number of configuration files and load them
    at any time. Say someone had to use Windows, and they had a file in thier C: drive, this would be
    loaded via::

      Config.readConfigFile("C:/my_config_file.txt")

    Note, the forward slash works on both Unix and Windows, using the forward slash eliminates the
    need to use a double back slash, "\\\\\\\\".

    """
    return _roadrunner.Config_readConfigFile(path)

def Config_writeConfigFile(path: "std::string const &") -> "void":
    r"""

    Config.writeConfigFile(path)

    Write all of the current configuration values to a file. This could be written to one of the
    default locations, or to any other location, and re-loaded at a later time.



    Available Configuration Parameters
    ----------------------------------
    All of the configuration parameter keys are static attributes of the Config class and are listed
    here. The variable type of the parameter is listed after the key name.

    """
    return _roadrunner.Config_writeConfigFile(path)

def Config_stringToKey(key: "std::string const &") -> "rr::Config::Keys":
    return _roadrunner.Config_stringToKey(key)

def Config_getKeyList() -> "std::vector< std::string,std::allocator< std::string > >":
    return _roadrunner.Config_getKeyList()

VALIDATE_UNITS = _roadrunner.VALIDATE_UNITS
r"""
    Check consistency of measurement units associated
    with quantities (SBML L2V4 rules 105nn)
    """
VALIDATE_IDENTIFIER = _roadrunner.VALIDATE_IDENTIFIER
r"""
    Check correctness and consistency of identifiers used
    for model entities (SBML L2V4 rules 103nn)
    """
VALIDATE_MATHML = _roadrunner.VALIDATE_MATHML
r"""
    Check syntax of MathML mathematical expressions
    (SBML L2V4 rules 102nn)
    """
VALIDATE_SBO = _roadrunner.VALIDATE_SBO
r"""
    Check validity of SBO identifiers (if any) used in
    the model (SBML L2V4 rules 107nn)
    """
VALIDATE_OVERDETERMINED = _roadrunner.VALIDATE_OVERDETERMINED
r"""Perform static analysis of whether the model is overdetermined"""
VALIDATE_MODELING_PRACTICE = _roadrunner.VALIDATE_MODELING_PRACTICE
r"""Perform additional checks for recommended good modeling practices"""
VALIDATE_GENERAL = _roadrunner.VALIDATE_GENERAL
r"""
    Perform all other general SBML consistency checks
    (SBML L2V4 rules 2nnnn; highly recommended)
    """

def validateSBML(*args, **kwargs) -> "std::string":
    return _roadrunner.validateSBML(*args, **kwargs)

def fixMissingStoichAndMath(sbml: "std::string const") -> "std::string":
    r"""
    Adds missing stoichiometry information and removes elements with no math.
    Assumes unit stoichiometry where not specified
    :rtype: string
    :return: SBML std::string with stoich fixed
    """
    return _roadrunner.fixMissingStoichAndMath(sbml)
class SBMLReader(object):
    r"""
    Read an sbml document from either disk, a remote url, or as a std::string.

    This function will first try to iterperet the std::string as uri, if that
    fails, it will try as a local file path, and finally if that fails, it will
    treat the std::string as whole sbml document and return the std::string.

    This is simple enough that it should belong in RoadRunner proper, however we currently
    use Poco for reading http streams, and it seems to compilation issues if "windows.h"
    is included before, an evidently some other roadrunner file includes windows.h,
    so we put all of this here by itself we we can make sure that there is no
    nasty windows files included.

    also, we put it as a static class method because libSBML already uses 'readSBML'
    and we want to avoid namespace collisions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def read(sbml_or_uri: "std::string const &") -> "std::string":
        r"""
        read an SBML document from a local file path, a remote URI, or
        directlly from a sbml std::string. If the document is a local file,
        and has the comp extension, it is automatically flattened before
        begin returned.

        If the std::string is already a SBML std::string, it is passed through.
        If the std::string is a local file or URI, the document is read
        from the source and the contents returned (and flattened if comp).
        """
        return _roadrunner.SBMLReader_read(sbml_or_uri)

    @staticmethod
    def is_sbml(str: "std::string const &") -> "bool":
        return _roadrunner.SBMLReader_is_sbml(str)

    def __init__(self):
        _roadrunner.SBMLReader_swiginit(self, _roadrunner.new_SBMLReader())
    __swig_destroy__ = _roadrunner.delete_SBMLReader

# Register SBMLReader in _roadrunner:
_roadrunner.SBMLReader_swigregister(SBMLReader)

def SBMLReader_read(sbml_or_uri: "std::string const &") -> "std::string":
    r"""
    read an SBML document from a local file path, a remote URI, or
    directlly from a sbml std::string. If the document is a local file,
    and has the comp extension, it is automatically flattened before
    begin returned.

    If the std::string is already a SBML std::string, it is passed through.
    If the std::string is a local file or URI, the document is read
    from the source and the contents returned (and flattened if comp).
    """
    return _roadrunner.SBMLReader_read(sbml_or_uri)

def SBMLReader_is_sbml(str: "std::string const &") -> "bool":
    return _roadrunner.SBMLReader_is_sbml(str)



from typing import List, Optional
import numpy as np
def plotTimeSeriesSens(time:np.array, sens:np.array,
                       rownames:List[str], colnames:List[str],
                       ncol:int=3, fname:Optional[str]=None):
    """Plot time series sensitivities

    The time, sens, rownames and colnames arguments are generated
    with a call to roadrunner.timeSeriesSensitivities.

    :param time (np.array): The time points at which the time series sensitivity analysis was conducted.
    :param sens (3D np.array): The sensitivity matrix.
    :param rownames (List[str]): Names of parameters
    :param colnames (List[str]: Names of species
    :param ncol (int): Number of columns to plot. The number of rows is computed based on this number (default=3)
    :param fname (str): Default=None, if specified, full path to where to save the output figure.

    Example
    ---------
    import roadrunner as rr
    from roadrunner.testing.TestModelFactory import TestModelFactory, getAvailableTestModels
    sbml = TestModelFactory("Venkatraman2010").str()  # get the test model's sbml string
    time, sens, rownames, colnames = model.timeSeriesSensitivities(
        0, 10, 101, params=["keff1", "keff2", "keff3"], species=["tcUPA", "scUPA"])
    plotTimeSeriesSens(time, sens, rownames, colnames)
    """
    import matplotlib.pyplot as plt
    import pandas as pd
    import seaborn as sns

    sns.set_style("white")
    sns.set_context("paper")

    total = len(rownames) * len(colnames)
    if ncol > total:
        ncol = total
    nrow = int(total / ncol if total % ncol == 0 else np.ceil(total / ncol))
    df_dct = {}
    for t, mat in zip(time, sens):
        df_dct[t] = pd.DataFrame(mat, columns=colnames, index=rownames)

    df = pd.concat(df_dct)
    df.index.names = ["time", "param"]
    df.columns.names = ["species"]
    df = df.unstack()
    print(df)
    fig, ax = plt.subplots(nrows=nrow, ncols=ncol)

    for j, species in enumerate(colnames):
        for i, param in enumerate(rownames):
            ax[i, j].plot(time, df[(species, param)].to_numpy(), label=f"{species}:{param}")
            sns.despine(ax=ax[i, j], top=True, right=True)
            ax[i, j].set_title(f"{species}:{param}")

            if j == 0:
                ax[i, j].set_ylabel(f"Sensitivities")

            if i == nrow-1:
                ax[i, j].set_xlabel(f"Time")

    fig.tight_layout()
    if fname is None:
        plt.show()
    else:
        fig.savefig(fname, dpi=300, bbox_inches='tight')


RoadRunner.registerSolvers()
integrators = list(RoadRunner.getRegisteredIntegratorNames())
steadyStateSolvers = list(RoadRunner.getRegisteredSteadyStateSolverNames())
solvers = integrators + steadyStateSolvers

class KinsolSteadyStateSolver(SteadyStateSolver):
    r"""
    Utility macro for checking for a variable for nullptr
    :param x: the pointer that is being checked for null
    :param fcn: the name of the function call that produced the null
    :param the: return type for :param fcn:

    base class to steady state solvers from the
    Sundials package.
    The steady state solver in Sundials
    is called Kinsol. They have multiple different strategies
    some which require model integration, and some that do not.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_KinsolSteadyStateSolver

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        implementation of Solver::syncWithModel.
        called by the main RoadRunner class to
        syncronize the model with its solvers (to be sure
        were not simulating an out of date model).
        """
        return _roadrunner.KinsolSteadyStateSolver_syncWithModel(self, m)

    def setFScale(self, *args) -> "void":
        r"""
        *Overload 1:*

        set all elements of the fscale variable to :type value: float
        :param value:.

        |

        *Overload 2:*

        set elements of the fscale variable to :type value: std::vector< double,std::allocator< double > >
        :param value:.
        :type value: std::vector< double,std::allocator< double > >
        :param value: should have the same size as the state std::vector
        """
        return _roadrunner.KinsolSteadyStateSolver_setFScale(self, *args)

    def setUScale(self, *args) -> "void":
        r"""
        *Overload 1:*

        set all elements of the uscale variable to :type value: float
        :param value:.

        |

        *Overload 2:*

        set elements of the uscale variable to :type value: std::vector< double,std::allocator< double > >
        :param value:.
        :type value: std::vector< double,std::allocator< double > >
        :param value: should have the same size as the state std::vector
        """
        return _roadrunner.KinsolSteadyStateSolver_setUScale(self, *args)

    def solveForSteadyState(self, solverInstance: "KinsolSteadyStateSolver", kinsolStrategy: "int") -> "double":
        r"""
        Generic solver method. When this method is called
        sundials steady state algorithms solver for steady state.
        Subclasses use specialized versions of this template
        using their desired kinsol strategy.
        this method cannot be called `solve()` since that
        is already taken with different signature requirements.
        :type solverInstance: :py:class:`KinsolSteadyStateSolver`
        :param solverInstance: pointer (non owning) to instance of subclass of
             KinsolSteadyStateSolver.
        :type kinsolStrategy: int
        :param kinsolStrategy: one of:
             - KIN_NONE: basic newton iteration
             - KIN_LINESEARCH: newton iteration with linesearch globalization
             - KIN_FP: Fixed point iteration, with anderson acceleration (no linear solver is used)
             - KIN_PICCARD: Piccad iteration, with anderson aceleration (with linear solver)
            These options are macro's defined by sundials. They correspond to :
                 KIN_NONE       0
                 KIN_LINESEARCH 1
                 KIN_PICARD     2
                 KIN_FP         3
        """
        return _roadrunner.KinsolSteadyStateSolver_solveForSteadyState(self, solverInstance, kinsolStrategy)

    def getKinsolMemory(self) -> "void *":
        r"""
        getter for the underlying memory block
        that is used by kinsol.
        mostly useful in testing.
        """
        return _roadrunner.KinsolSteadyStateSolver_getKinsolMemory(self)

    def getSolverStats(self) -> "std::unordered_map< std::string,Setting,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,Setting > > > &":
        r"""
        return a mapping containing solver statistics.
        only filled once solve has been called.
        See also: getSolverStatsFromKinsol which actually collects the data
        from kinsol. Whereas this method returns the data in a unordered_map
        """
        return _roadrunner.KinsolSteadyStateSolver_getSolverStats(self)

    def printSolverStats(self) -> "void":
        r"""display solver stats to console"""
        return _roadrunner.KinsolSteadyStateSolver_printSolverStats(self)

# Register KinsolSteadyStateSolver in _roadrunner:
_roadrunner.KinsolSteadyStateSolver_swigregister(KinsolSteadyStateSolver)

class NewtonIteration(KinsolSteadyStateSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_NewtonIteration

    def getName(self) -> "std::string":
        r"""Get the name of this solver"""
        return _roadrunner.NewtonIteration_getName(self)

    def getDescription(self) -> "std::string":
        r"""Get the description of this solver"""
        return _roadrunner.NewtonIteration_getDescription(self)

    def getHint(self) -> "std::string":
        r"""Get a (user-readable) hint for this solver"""
        return _roadrunner.NewtonIteration_getHint(self)

    def resetSettings(self) -> "void":
        r"""reset settings back to default."""
        return _roadrunner.NewtonIteration_resetSettings(self)

    def getSolverStatsFromKinsol(self) -> "void":
        return _roadrunner.NewtonIteration_getSolverStatsFromKinsol(self)

# Register NewtonIteration in _roadrunner:
_roadrunner.NewtonIteration_swigregister(NewtonIteration)

class BasicNewtonIteration(NewtonIteration):
    r"""
    Solve for steady state using Kinsol's implementation
    of Newton Iteration.
    The kinsol docs refer to this algorithm as the "basic"
    newton iteration to differentiate it from the "linesearch" strategy
    which is a variant of the "basic" newton iteration.
    See also: LinesearchNewtonIteration
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_BasicNewtonIteration

    def __init__(self, executableModel: "ExecutableModel"):
        _roadrunner.BasicNewtonIteration_swiginit(self, _roadrunner.new_BasicNewtonIteration(executableModel))

    def getName(self) -> "std::string":
        r"""Get the name of this solver"""
        return _roadrunner.BasicNewtonIteration_getName(self)

    def getDescription(self) -> "std::string":
        r"""Get the description of this solver"""
        return _roadrunner.BasicNewtonIteration_getDescription(self)

    def getHint(self) -> "std::string":
        r"""Get a (user-readable) hint for this solver"""
        return _roadrunner.BasicNewtonIteration_getHint(self)

    def construct(self, model: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct a new BasicNewtonIterator
        caller is responsible for deleting memory returned.
        """
        return _roadrunner.BasicNewtonIteration_construct(self, model)

    def solve(self) -> "double":
        r"""solve the currently defined problem"""
        return _roadrunner.BasicNewtonIteration_solve(self)

# Register BasicNewtonIteration in _roadrunner:
_roadrunner.BasicNewtonIteration_swigregister(BasicNewtonIteration)

class LinesearchNewtonIteration(NewtonIteration):
    r"""
    Solve for steady state using Kinsol's implementation
    of Newton Iteration with linesearch globalization
    See also: BasicNewtonIteration

    .. code-block:: c++

         RoadRunner rr(sbml);
         rr.setSteadyStateSolver("newton_linesearch");
         rr.solve();
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_LinesearchNewtonIteration

    def __init__(self, executableModel: "ExecutableModel"):
        _roadrunner.LinesearchNewtonIteration_swiginit(self, _roadrunner.new_LinesearchNewtonIteration(executableModel))

    def getName(self) -> "std::string":
        r"""Get the name of this solver"""
        return _roadrunner.LinesearchNewtonIteration_getName(self)

    def getDescription(self) -> "std::string":
        r"""Get the description of this solver"""
        return _roadrunner.LinesearchNewtonIteration_getDescription(self)

    def getHint(self) -> "std::string":
        r"""Get a (user-readable) hint for this solver"""
        return _roadrunner.LinesearchNewtonIteration_getHint(self)

    def construct(self, model: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct a new LinesearchNewtonIteration
        caller is responsible for deleting memory returned.
        """
        return _roadrunner.LinesearchNewtonIteration_construct(self, model)

    def solve(self) -> "double":
        r"""solve the currently defined problem"""
        return _roadrunner.LinesearchNewtonIteration_solve(self)

# Register LinesearchNewtonIteration in _roadrunner:
_roadrunner.LinesearchNewtonIteration_swigregister(LinesearchNewtonIteration)

class NLEQSolver(SteadyStateSolver):
    r"""Base class for NLEQ type steady state solvers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_NLEQSolver

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.NLEQSolver_syncWithModel(self, m)

    def loadConfigSettings(self) -> "void":
        return _roadrunner.NLEQSolver_loadConfigSettings(self)

    def resetSettings(self) -> "void":
        r"""Reset all integrator settings to their respective default values"""
        return _roadrunner.NLEQSolver_resetSettings(self)

# Register NLEQSolver in _roadrunner:
_roadrunner.NLEQSolver_swigregister(NLEQSolver)

class NLEQ1Solver(NLEQSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _model: "ExecutableModel"):
        _roadrunner.NLEQ1Solver_swiginit(self, _roadrunner.new_NLEQ1Solver(_model))

    def getName(self) -> "std::string":
        r"""
        Author: WBC, JKM
        Get the name for this Solver
        Notes: Delegates to 'getName'
        """
        return _roadrunner.NLEQ1Solver_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: WBC
        Get the description for this Solver
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.NLEQ1Solver_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this Solver
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.NLEQ1Solver_getHint(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct an instance of NLEQ1Solver
        Caller is responsible for deleting memory
        associated with returned Solver*.
        """
        return _roadrunner.NLEQ1Solver_construct(self, executableModel)

    def solve(self) -> "double":
        return _roadrunner.NLEQ1Solver_solve(self)
    __swig_destroy__ = _roadrunner.delete_NLEQ1Solver

# Register NLEQ1Solver in _roadrunner:
_roadrunner.NLEQ1Solver_swigregister(NLEQ1Solver)

class NLEQ2Solver(NLEQSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getName(self) -> "std::string":
        r"""
        Author: WBC, JKM
        Get the name for this Solver
        Notes: Delegates to 'getName'
        """
        return _roadrunner.NLEQ2Solver_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: WBC
        Get the description for this Solver
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.NLEQ2Solver_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this Solver
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.NLEQ2Solver_getHint(self)

    def solve(self) -> "double":
        return _roadrunner.NLEQ2Solver_solve(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct an instance of NLEQ2Solver
        Caller is responsible for deleting memory
        associated with returned Solver*.
        """
        return _roadrunner.NLEQ2Solver_construct(self, executableModel)
    __swig_destroy__ = _roadrunner.delete_NLEQ2Solver

# Register NLEQ2Solver in _roadrunner:
_roadrunner.NLEQ2Solver_swigregister(NLEQ2Solver)

class ForwardSensitivitySolver(TimeSeriesSensitivitySolver):
    r"""
    Time based sensivitity solver.
    Uses CVODEIntegrator to integrate the ExecutableModel
    and cvodes to compute sensitivity information at each time point.
    Implements the TimeSeriesSensitivitySolver interface
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_ForwardSensitivitySolver

    def __init__(self, *args):
        _roadrunner.ForwardSensitivitySolver_swiginit(self, _roadrunner.new_ForwardSensitivitySolver(*args))

    def integrate(self, tStart: "double", hstep: "double") -> "double":
        return _roadrunner.ForwardSensitivitySolver_integrate(self, tStart, hstep)

    def create(self) -> "void":
        r"""instantiate the code necessary to use cvodes"""
        return _roadrunner.ForwardSensitivitySolver_create(self)

    def freeSundialsMemory(self) -> "void":
        r"""free sundials memory associated with sensitivities"""
        return _roadrunner.ForwardSensitivitySolver_freeSundialsMemory(self)

    def getName(self) -> "std::string":
        r"""Get the name of this solver"""
        return _roadrunner.ForwardSensitivitySolver_getName(self)

    def getDescription(self) -> "std::string":
        r"""Get the description of this solver"""
        return _roadrunner.ForwardSensitivitySolver_getDescription(self)

    def getHint(self) -> "std::string":
        r"""Get a (user-readable) hint for this solver"""
        return _roadrunner.ForwardSensitivitySolver_getHint(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        return _roadrunner.ForwardSensitivitySolver_construct(self, executableModel)

    def resetSettings(self) -> "void":
        r"""resets all settings back to default values"""
        return _roadrunner.ForwardSensitivitySolver_resetSettings(self)

    def syncWithModel(self, executableModel: "ExecutableModel") -> "void":
        return _roadrunner.ForwardSensitivitySolver_syncWithModel(self, executableModel)

    def toRepr(self) -> "std::string":
        return _roadrunner.ForwardSensitivitySolver_toRepr(self)

    def loadConfigSettings(self) -> "void":
        return _roadrunner.ForwardSensitivitySolver_loadConfigSettings(self)

    def toString(self) -> "std::string":
        return _roadrunner.ForwardSensitivitySolver_toString(self)

    def getGlobalParameterNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        returns a vector of global parameter names
        extracted from the model
        """
        return _roadrunner.ForwardSensitivitySolver_getGlobalParameterNames(self)

    def getVariableNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        get a vector of variable names in the order that
        they appear in the model.
        variables refers to each equation in the model
        and are obtained with ExecutableModel::getStateVectorId.
        """
        return _roadrunner.ForwardSensitivitySolver_getVariableNames(self)

    def getModelParametersAsMap(self) -> "rr::ParameterMap":
        r"""
        get global parameters as an unordered map, strings as
        keys and parameter values as values
        """
        return _roadrunner.ForwardSensitivitySolver_getModelParametersAsMap(self)

    def getModelParametersAsVector(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        return a std::vector<double> of model parameters
        in the order they appear in the model.
        """
        return _roadrunner.ForwardSensitivitySolver_getModelParametersAsVector(self)

    def deducePlist(self) -> "void":
        r"""
        returns the indexes of parameters that user wants
        sensitivities for, based off of whichParameters.
        """
        return _roadrunner.ForwardSensitivitySolver_deducePlist(self)

    def getStateVector(self) -> "N_Vector":
        r"""
        retuns pointer to the state vector
        used by sundials for solving ODE.
        """
        return _roadrunner.ForwardSensitivitySolver_getStateVector(self)

    def getSensitivityNVectorPtr(self) -> "N_Vector *":
        r"""
        retuns pointer to the state vector
        used by sundials for storing sensitivity matrix.
        """
        return _roadrunner.ForwardSensitivitySolver_getSensitivityNVectorPtr(self)

    def getSensitivityMatrix(self, k: "int"=0) -> "rr::Matrix< double >":
        r"""
        get current values of sensitivities of model variables
        to parameters.
        :param kth: derivative of the sensitivities.
        """
        return _roadrunner.ForwardSensitivitySolver_getSensitivityMatrix(self, k)

    def solveSensitivities(self, *args, **kwargs) -> "rr::Matrix3D< double,double >":
        r"""
        simulate a timeseries with sensitivities from start to step with num
        data points.
        Matrix3D indexed by time. Each element of the 3D matrix is a
        Matrix<double> with rows and columns parameters and model variables respectively.
        The parameter k determines the kth order derivative of the sensitivity information
        that will be returned
        :type start: float
        :param start: starting time for time series simulation
        :type stop: float
        :param stop: last time point for time series simulation
        :type num: int
        :param num: number of data points to simulate. Determines Z of Matrix3D.
        :type params: std::vector< std::string,std::allocator< std::string > >, optional
        :param params: vector of parameters that you want sensitivity for. When empty (default), compute
            sensitivities for all parameters vs all variables.
        :type k: int, optional
        :param k: (default 0) return the kth other derivative of the sensitivity data.
        Notes: for developers. Pass by value for the params is easier to wrap with swig.
        """
        return _roadrunner.ForwardSensitivitySolver_solveSensitivities(self, *args, **kwargs)

    def setValue(self, key: "std::string const &", val: "Setting") -> "void":
        return _roadrunner.ForwardSensitivitySolver_setValue(self, key, val)
    p = property(_roadrunner.ForwardSensitivitySolver_p_get, _roadrunner.ForwardSensitivitySolver_p_set, doc=r"""
    parameters in the model as a member variable
    which enables passing the underlying data pointer to
    sundials for finite difference approx
    This is the full vector of model global
    parameters in the order indexed in the model.
    See also: plist
    """)
    pbar = property(_roadrunner.ForwardSensitivitySolver_pbar_get, _roadrunner.ForwardSensitivitySolver_pbar_set, doc=r"""
    scaling factors. Set to the values of
    the parameters for sensitivity. This should
    be identical to p as acceptible default.
    """)
    plist = property(_roadrunner.ForwardSensitivitySolver_plist_get, _roadrunner.ForwardSensitivitySolver_plist_set, doc=r"""
    which parameters to get sensitivity for as int?
    indexes parameters in p and pbar.
    """)
    whichParameters = property(_roadrunner.ForwardSensitivitySolver_whichParameters_get, _roadrunner.ForwardSensitivitySolver_whichParameters_set, doc=r"""which parameters to get sensitivities for, as strings""")
    globalParameterMap = property(_roadrunner.ForwardSensitivitySolver_globalParameterMap_get, _roadrunner.ForwardSensitivitySolver_globalParameterMap_set, doc=r"""a map containing model parameter names to values""")
    Np = property(_roadrunner.ForwardSensitivitySolver_Np_get, _roadrunner.ForwardSensitivitySolver_Np_set, doc=r"""number of global parameters in the model""")
    Ns = property(_roadrunner.ForwardSensitivitySolver_Ns_get, _roadrunner.ForwardSensitivitySolver_Ns_set, doc=r"""number of parameters we want to find sensitivities for""")
    numModelVariables = property(_roadrunner.ForwardSensitivitySolver_numModelVariables_get, _roadrunner.ForwardSensitivitySolver_numModelVariables_set, doc=r"""
    the number of state variables in the model
    aka the size of the mStateVector
    """)

# Register ForwardSensitivitySolver in _roadrunner:
_roadrunner.ForwardSensitivitySolver_swigregister(ForwardSensitivitySolver)

class CVODEIntegrator(Integrator):
    r"""
    Author: WBC, ETS, MTK
    A RoadRunner integrator based on CVODE; serves as RoadRunner's main integrator for ODEs
    Provides a wrapper around CVODE from the SUNDIALS suite.
    CVODE has two main solvers: an Adams-Moulton solver for non-stiff problems,
    and a backward differentiation formula (BDF) solver for stiff problems.
    See: https://computation.llnl.gov/casc/sundials/documentation/toms_sundials.pdf
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, oModel: "ExecutableModel"):
        r"""
        Author: WBC, ETS, MTK
        Constructor: takes an executable model, does not own the pointer
        """
        _roadrunner.CVODEIntegrator_swiginit(self, _roadrunner.new_CVODEIntegrator(oModel))
    __swig_destroy__ = _roadrunner.delete_CVODEIntegrator

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.CVODEIntegrator_syncWithModel(self, m)

    def loadConfigSettings(self) -> "void":
        r"""
        It looks like this method only get used
        inside resetSettings.
        """
        return _roadrunner.CVODEIntegrator_loadConfigSettings(self)

    def loadSBMLSettings(self, filename: "std::string const &") -> "void":
        r"""
        Author: WBC
        Load an SBML settings file and apply the configuration options
        Notes: Can assign relative and absolute tolerances
        """
        return _roadrunner.CVODEIntegrator_loadSBMLSettings(self, filename)

    def getName(self) -> "std::string":
        r"""
        Author: WBC
        Get the name for this integrator
        Notes: Delegates to 'getName'
        """
        return _roadrunner.CVODEIntegrator_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: WBC
        Get the description for this integrator
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.CVODEIntegrator_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this integrator
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.CVODEIntegrator_getHint(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct an instance of type CVODEIntegrator.
        implements the Registrar interface. Used in
        factory creation of Integrators.
        """
        return _roadrunner.CVODEIntegrator_construct(self, executableModel)

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        r"""
        Author: WBC, ETS, MTK
        Always deterministic for CVODE
        """
        return _roadrunner.CVODEIntegrator_getIntegrationMethod(self)

    def setValue(self, setting: "std::string const &", value: "Setting") -> "void":
        r"""
        Author: WBC, ETS, MTK
        Sets the value of an integrator setting (e.g. absolute_tolerance)
        """
        return _roadrunner.CVODEIntegrator_setValue(self, setting, value)

    def setMaxOrder(self, newValue: "int") -> "void":
        r"""
        sets the value of maximum order, which defaults to 12 for Adams (non-stiff)
        and 5 for BDF (Stiff).
        Once a CVODEIntegrator has been created, increasing the
        order value beyond the original value is not possible (because the underlying
        sundials objects require more memory). Attempts to do so will simply be ignored.
        """
        return _roadrunner.CVODEIntegrator_setMaxOrder(self, newValue)

    def setIndividualTolerance(self, sid: "std::string", value: "double") -> "void":
        r"""
        Author: FY
        Sets tolerance for individual species
        """
        return _roadrunner.CVODEIntegrator_setIndividualTolerance(self, sid, value)

    def setConcentrationTolerance(self, value: "Setting") -> "void":
        r"""
        Author: FY
        Sets tolerance based on concentration of species
        First converts the concentration tolerances to amount tolerances
        by multiplying the compartment volume of species. Whichever is smaller
        will be stored as absolute_tolerance and used in the integration process.
        """
        return _roadrunner.CVODEIntegrator_setConcentrationTolerance(self, value)

    def getConcentrationTolerance(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Author: FY
        Gets tolerance based on concentration of species
        """
        return _roadrunner.CVODEIntegrator_getConcentrationTolerance(self)

    def resetSettings(self) -> "void":
        r"""
        Author: JKM
        Reset all integrator settings to their respective default values
        """
        return _roadrunner.CVODEIntegrator_resetSettings(self)

    def tweakTolerances(self) -> "void":
        r"""
        Author: JKM, WBC, ETS, MTK
        Fix tolerances for SBML tests
        In order to ensure that the results of the SBML test suite
        remain valid, this method enforces a lower bound on tolerance values.
        Sets minimum absolute and relative tolerances to
        Config::CVODE_MIN_ABSOLUTE and Config::CVODE_MIN_RELATIVE resp.
        """
        return _roadrunner.CVODEIntegrator_tweakTolerances(self)

    def integrate(self, t0: "double", hstep: "double") -> "double":
        r"""
        Author: WBC, ETS, MTK
        Main integration routine
        """
        return _roadrunner.CVODEIntegrator_integrate(self, t0, hstep)

    def restart(self, timeStart: "double") -> "void":
        r"""
        Author: WBC, ETS, MTK
        Reset time to zero and reinitialize model
        Applies events which occur before time zero.
        Reinitializes CVODE and the executable model.
        """
        return _roadrunner.CVODEIntegrator_restart(self, timeStart)

    def setListener(self, arg2: "rr::IntegratorListenerPtr") -> "void":
        r"""
        Author: WBC, ETS
        Sets the integrator listener
        """
        return _roadrunner.CVODEIntegrator_setListener(self, arg2)

    def checkType(self) -> "void":
        r"""
        Author: JKM
        Does a RT type check which throws if it fails, EVEN IF RTTI IS DISABLED
        """
        return _roadrunner.CVODEIntegrator_checkType(self)

    def checkVectorSize(self, expected: "int", real: "size_t") -> "void":
        r"""
        Author: FY
        Does a size check which throws if it fails
        """
        return _roadrunner.CVODEIntegrator_checkVectorSize(self, expected, real)

    def checkIndex(self, index: "int", size: "int") -> "void":
        r"""
        Author: FY
        Does a index check which throws if it is out of bound
        """
        return _roadrunner.CVODEIntegrator_checkIndex(self, index, size)

    def ToString(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Author: FY
        Converts integer to std::string for error print

        |

        *Overload 2:*

        Author: LPS
        Converts size_t to std::string for error print
        """
        return _roadrunner.CVODEIntegrator_ToString(self, *args)

    def getStateVector(self) -> "N_Vector":
        r"""getter for the internal state std::vector"""
        return _roadrunner.CVODEIntegrator_getStateVector(self)

    def getSolver(self) -> "SUNNonlinearSolver":
        r"""getter for the internal Sundials linear solver object"""
        return _roadrunner.CVODEIntegrator_getSolver(self)

    def getCvodeMemory(self) -> "void *":
        r"""getter for the internal CVode memory buffer"""
        return _roadrunner.CVODEIntegrator_getCvodeMemory(self)

# Register CVODEIntegrator in _roadrunner:
_roadrunner.CVODEIntegrator_swigregister(CVODEIntegrator)

class GillespieIntegrator(Integrator):
    r"""
    Author: WBC, ETS
    RoadRunner's implementation of the Gillespie SSA
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "ExecutableModel"):
        _roadrunner.GillespieIntegrator_swiginit(self, _roadrunner.new_GillespieIntegrator(model))
    __swig_destroy__ = _roadrunner.delete_GillespieIntegrator

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.GillespieIntegrator_syncWithModel(self, m)

    def getName(self) -> "std::string":
        r"""
        Author: WBC
        Get the name for this integrator
        Notes: Delegates to 'getName'
        """
        return _roadrunner.GillespieIntegrator_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: WBC
        Get the description for this integrator
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.GillespieIntegrator_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this integrator
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.GillespieIntegrator_getHint(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        return _roadrunner.GillespieIntegrator_construct(self, executableModel)

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        r"""
        Author: WBC, ETS
        Always stochastic for Gillespie
        """
        return _roadrunner.GillespieIntegrator_getIntegrationMethod(self)

    def setValue(self, setting: "std::string const &", value: "Setting") -> "void":
        r"""
        Author: WBC, ETS
        Sets the value of an integrator setting (e.g. absolute_tolerance)
        """
        return _roadrunner.GillespieIntegrator_setValue(self, setting, value)

    def resetSettings(self) -> "void":
        r"""
        Author: JKM
        Reset all integrator settings to their respective default values
        """
        return _roadrunner.GillespieIntegrator_resetSettings(self)

    def integrate(self, t0: "double", tf: "double") -> "double":
        r"""
        Author: WBC, ETS
        Main integration routine
        """
        return _roadrunner.GillespieIntegrator_integrate(self, t0, tf)

    def restart(self, timeStart: "double") -> "void":
        r"""
        Author: WBC, ETS
        Reset time to zero and reinitialize model
        """
        return _roadrunner.GillespieIntegrator_restart(self, timeStart)

    def setListener(self, arg2: "rr::IntegratorListenerPtr") -> "void":
        r"""
        Author: WBC, ETS
        Sets the integrator listener
        """
        return _roadrunner.GillespieIntegrator_setListener(self, arg2)

# Register GillespieIntegrator in _roadrunner:
_roadrunner.GillespieIntegrator_swigregister(GillespieIntegrator)

class RK4Integrator(Integrator):
    r"""
    A super basic 4'th order fixed step integrator.

    The RungeKuttaIntegrator will be the more sophisticated,
    general purpose Runge-Kutta integrator which will support
    different orders and adaptive time stepping.

    This object is mainly here as an example of creating a new Integrator.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "ExecutableModel"):
        r"""
        Creates a new RK4Integrator.

        The IntegratorFactory is the ONLY object that creates integrators.

        Integrators are created when the IntegratorFactory::New method is called,
        typically by the top level RoadRunner object.

        The integrator will hold onto the ExecutableModel pointer, m, and when the
        integrate method is called, will advance the model object forward in time.

        :type m: :py:class:`ExecutableModel`
        :param m:: a borrowed reference to an existing ExecutableModel object.
        :param o:: a reference to a SimulatOptions object where the configuration
            parameters will be read from.
        """
        _roadrunner.RK4Integrator_swiginit(self, _roadrunner.new_RK4Integrator(m))
    __swig_destroy__ = _roadrunner.delete_RK4Integrator

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.RK4Integrator_syncWithModel(self, m)

    def integrate(self, t0: "double", tf: "double") -> "double":
        r"""integrates the model from t0 to tf."""
        return _roadrunner.RK4Integrator_integrate(self, t0, tf)

    def restart(self, t0: "double") -> "void":
        r"""
        copies the state std::vector out of the model and into cvode std::vector,
        re-initializes cvode.
        """
        return _roadrunner.RK4Integrator_restart(self, t0)

    def getName(self) -> "std::string":
        r"""
        Author: JKM
        Get the name for this integrator
        Notes: Delegates to 'getName'
        """
        return _roadrunner.RK4Integrator_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: JKM
        Get the description for this integrator
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.RK4Integrator_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this integrator
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.RK4Integrator_getHint(self)

    def construct(self, model: "ExecutableModel") -> "rr::Solver *":
        r"""
        construct an instance of type RK4Integrator.
        implements the Registrar interface. Used in
        factory creation of Integrators.
        """
        return _roadrunner.RK4Integrator_construct(self, model)

    def getValue(self, key: "std::string") -> "Setting":
        return _roadrunner.RK4Integrator_getValue(self, key)

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        r"""
        Author: JKM
        Always deterministic for RK4
        """
        return _roadrunner.RK4Integrator_getIntegrationMethod(self)

    def resetSettings(self) -> "void":
        r"""
        Author: JKM
        Reset all integrator settings to their respective default values
        """
        return _roadrunner.RK4Integrator_resetSettings(self)

    def setListener(self, arg2: "rr::IntegratorListenerPtr") -> "void":
        r"""
        the integrator can hold a single listener. If clients require multicast,
        they can create a multi-cast listener.
        """
        return _roadrunner.RK4Integrator_setListener(self, arg2)

# Register RK4Integrator in _roadrunner:
_roadrunner.RK4Integrator_swigregister(RK4Integrator)

class RK45Integrator(Integrator):
    r"""
    Author: KC
    A Runge-Kutta Fehlberg method for roadrunner
    Uses the Fehlberg method, an adaptive step
    method, to integrate models.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "ExecutableModel"):
        r"""
        Author: KC
        Constructor: takes an executable model, does not own the pointer
        """
        _roadrunner.RK45Integrator_swiginit(self, _roadrunner.new_RK45Integrator(m))
    __swig_destroy__ = _roadrunner.delete_RK45Integrator

    def syncWithModel(self, m: "ExecutableModel") -> "void":
        r"""
        Author: JKM
        Called whenever a new model is loaded to allow integrator
        to reset internal state
        """
        return _roadrunner.RK45Integrator_syncWithModel(self, m)

    def integrate(self, t: "double", h: "double") -> "double":
        r"""
        Author: CC
        Integrates the model from t to t + h.
        Attempts to find the state std::vector at
        t + h, and returns time t + h if successful.
        If the integrator does not find a convergent
        solution, the state std::vector is not updated and
        t is returned.
        Also calculates a new timestep and saves it
        to a member variable for future use.
        """
        return _roadrunner.RK45Integrator_integrate(self, t, h)

    def restart(self, t0: "double") -> "void":
        r"""Restarts the integrator"""
        return _roadrunner.RK45Integrator_restart(self, t0)

    def getName(self) -> "std::string":
        r"""
        Author: JKM
        Get the name for this integrator
        Notes: Delegates to 'getName'
        """
        return _roadrunner.RK45Integrator_getName(self)

    @staticmethod
    def getRK45Name() -> "std::string":
        r"""
        Author: JKM
        Get the name for this integrator
        """
        return _roadrunner.RK45Integrator_getRK45Name()

    def getDescription(self) -> "std::string":
        r"""
        Author: JKM
        Get the description for this integrator
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.RK45Integrator_getDescription(self)

    @staticmethod
    def getRK45Description() -> "std::string":
        r"""
        Author: JKM
        Get the description for this integrator
        """
        return _roadrunner.RK45Integrator_getRK45Description()

    def getHint(self) -> "std::string":
        r"""
        Author: WBC
        Get the hint for this integrator
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.RK45Integrator_getHint(self)

    @staticmethod
    def getRK45Hint() -> "std::string":
        r"""
        Author: JKM
        Get the hint for this integrator
        """
        return _roadrunner.RK45Integrator_getRK45Hint()

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        return _roadrunner.RK45Integrator_construct(self, executableModel)

    def getValue(self, key: "std::string") -> "Setting":
        return _roadrunner.RK45Integrator_getValue(self, key)

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        r"""
        Author: JKM
        Always deterministic for RK45
        """
        return _roadrunner.RK45Integrator_getIntegrationMethod(self)

    def resetSettings(self) -> "void":
        r"""
        Author: JKM
        Reset all integrator settings to their respective default values
        """
        return _roadrunner.RK45Integrator_resetSettings(self)

    def setListener(self, arg2: "rr::IntegratorListenerPtr") -> "void":
        r"""
        the integrator can hold a single listener. If clients require multicast,
        they can create a multi-cast listener.
        """
        return _roadrunner.RK45Integrator_setListener(self, arg2)

# Register RK45Integrator in _roadrunner:
_roadrunner.RK45Integrator_swigregister(RK45Integrator)

def RK45Integrator_getRK45Name() -> "std::string":
    r"""
    Author: JKM
    Get the name for this integrator
    """
    return _roadrunner.RK45Integrator_getRK45Name()

def RK45Integrator_getRK45Description() -> "std::string":
    r"""
    Author: JKM
    Get the description for this integrator
    """
    return _roadrunner.RK45Integrator_getRK45Description()

def RK45Integrator_getRK45Hint() -> "std::string":
    r"""
    Author: JKM
    Get the hint for this integrator
    """
    return _roadrunner.RK45Integrator_getRK45Hint()

class EulerIntegrator(Integrator):
    r"""
    An example class intended to show how to create
    an Integrator. This class implements the most
    basic possible integration algorithm: the forward Euler method.

    This integrator should not really be used in practice as the
    forward Euler algorithm is highly unstable and will seldomly
    yield numerically correct values.

    This class also has two dummy variables, exampleParameter1 and
    exampleParameter2. These serve as examples of how to use the Dictionary
    interface to get/set various tuning paramters that an Integrator
    might have. These values will be displayed when the toString method
    is called, typically by Python.

    An example of calling simulate in Python, and the results of specifying
    the parameters as keyword arguments is

    .. code-block:: c++

        r.simulate(integrator='euler', exampleParameter1=123456, exampleParameter2='some value');

        print(r.integrator)
        < roadrunner.EulerIntegrator()
        { 'this' : 0x101f28350
        'exampleParameter1' : 123456
        'exampleParameter2' : some value
        }>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "ExecutableModel"):
        r"""
        Creates a new EulerIntegrator.

        The IntegratorFactory is the ONLY object that creates integrators.

        Integrators are created when the IntegratorFactory::New method is called,
        typically by the top level RoadRunner object.

        The integrator will hold onto the ExecutableModel pointer, m, and when the
        integrate method is called, will advance the model object forward in time.

        :type m: :py:class:`ExecutableModel`
        :param m:: a borrowed reference to an existing ExecutableModel object.
        :param o:: a reference to a SimulatOptions object where the configuration
            parameters will be read from.
        """
        _roadrunner.EulerIntegrator_swiginit(self, _roadrunner.new_EulerIntegrator(m))
    __swig_destroy__ = _roadrunner.delete_EulerIntegrator

    def integrate(self, t0: "double", h: "double") -> "double":
        r"""
        integrates the model from t0 to t0 + hstep

        In this implementation, this performs a basic forward Euler step.
        This method also demonstrates how to notify the listener
        that a timestep has completed.

        :rtype: float
        :return: the end time.
        """
        return _roadrunner.EulerIntegrator_integrate(self, t0, h)

    def applyEvents(self, timeEnd: "double", previousEventStatus: "std::vector< unsigned char,std::allocator< unsigned char > > &") -> "void":
        return _roadrunner.EulerIntegrator_applyEvents(self, timeEnd, previousEventStatus)

    def restart(self, t0: "double") -> "void":
        r"""This simple integrator has nothing to reset, so do nothing here"""
        return _roadrunner.EulerIntegrator_restart(self, t0)

    def setListener(self, p: "rr::IntegratorListenerPtr") -> "void":
        r"""
        Clients may register a listener to listen for
        sbml events and time step events.
        """
        return _roadrunner.EulerIntegrator_setListener(self, p)

    def __str__(self) -> "std::string":
        r"""get a description of this object, compatable with python __str__"""
        return _roadrunner.EulerIntegrator___str__(self)

    def toRepr(self) -> "std::string":
        r"""get a short descriptions of this object, compatable with python __repr__."""
        return _roadrunner.EulerIntegrator_toRepr(self)

    def getName(self) -> "std::string":
        r"""get the name of this integrator"""
        return _roadrunner.EulerIntegrator_getName(self)

    def getDescription(self) -> "std::string":
        r"""
        Author: JKM
        Get the description for this integrator
        Notes: Delegates to 'getDescription'
        """
        return _roadrunner.EulerIntegrator_getDescription(self)

    def getHint(self) -> "std::string":
        r"""
        Author: JKM
        Get the hint for this integrator
        Notes: Delegates to 'getHint'
        """
        return _roadrunner.EulerIntegrator_getHint(self)

    def construct(self, executableModel: "ExecutableModel") -> "rr::Solver *":
        return _roadrunner.EulerIntegrator_construct(self, executableModel)

    def getIntegrationMethod(self) -> "rr::Integrator::IntegrationMethod":
        r"""
        Author: JKM
        Always deterministic for Euler
        """
        return _roadrunner.EulerIntegrator_getIntegrationMethod(self)

    def resetSettings(self) -> "void":
        return _roadrunner.EulerIntegrator_resetSettings(self)

# Register EulerIntegrator in _roadrunner:
_roadrunner.EulerIntegrator_swigregister(EulerIntegrator)



